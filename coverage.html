
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">fund-o/api-server/cmd/api/main.go (0.0%)</option>
				
				<option value="file1">fund-o/api-server/cmd/api/server/server.go (0.0%)</option>
				
				<option value="file2">fund-o/api-server/cmd/worker/distributor.go (0.0%)</option>
				
				<option value="file3">fund-o/api-server/cmd/worker/logger.go (0.0%)</option>
				
				<option value="file4">fund-o/api-server/cmd/worker/processor.go (0.0%)</option>
				
				<option value="file5">fund-o/api-server/cmd/worker/task_send_verify_email.go (0.0%)</option>
				
				<option value="file6">fund-o/api-server/cmd/ws/client.go (0.0%)</option>
				
				<option value="file7">fund-o/api-server/cmd/ws/hub.go (0.0%)</option>
				
				<option value="file8">fund-o/api-server/cmd/ws/room.go (0.0%)</option>
				
				<option value="file9">fund-o/api-server/cmd/ws/socket_service.go (0.0%)</option>
				
				<option value="file10">fund-o/api-server/config/config.go (96.6%)</option>
				
				<option value="file11">fund-o/api-server/docs/docs.go (0.0%)</option>
				
				<option value="file12">fund-o/api-server/internal/datasource/datasource.go (0.0%)</option>
				
				<option value="file13">fund-o/api-server/internal/datasource/driver/sql.go (0.0%)</option>
				
				<option value="file14">fund-o/api-server/internal/datasource/repository/channel_repository.go (0.0%)</option>
				
				<option value="file15">fund-o/api-server/internal/datasource/repository/forum_repository.go (0.0%)</option>
				
				<option value="file16">fund-o/api-server/internal/datasource/repository/message_repository.go (0.0%)</option>
				
				<option value="file17">fund-o/api-server/internal/datasource/repository/mock/mock_transaction_repository.go (60.0%)</option>
				
				<option value="file18">fund-o/api-server/internal/datasource/repository/project_category_repository.go (0.0%)</option>
				
				<option value="file19">fund-o/api-server/internal/datasource/repository/project_repository.go (0.0%)</option>
				
				<option value="file20">fund-o/api-server/internal/datasource/repository/session_repository.go (0.0%)</option>
				
				<option value="file21">fund-o/api-server/internal/datasource/repository/transaction_repository.go (0.0%)</option>
				
				<option value="file22">fund-o/api-server/internal/datasource/repository/user_repository.go (0.0%)</option>
				
				<option value="file23">fund-o/api-server/internal/datasource/repository/verify_email_repository.go (0.0%)</option>
				
				<option value="file24">fund-o/api-server/internal/entity/channel.go (0.0%)</option>
				
				<option value="file25">fund-o/api-server/internal/entity/decimal.go (0.0%)</option>
				
				<option value="file26">fund-o/api-server/internal/entity/forum.go (33.3%)</option>
				
				<option value="file27">fund-o/api-server/internal/entity/message.go (0.0%)</option>
				
				<option value="file28">fund-o/api-server/internal/entity/project.go (42.9%)</option>
				
				<option value="file29">fund-o/api-server/internal/entity/project_category.go (80.0%)</option>
				
				<option value="file30">fund-o/api-server/internal/entity/session.go (100.0%)</option>
				
				<option value="file31">fund-o/api-server/internal/entity/transaction.go (100.0%)</option>
				
				<option value="file32">fund-o/api-server/internal/entity/user.go (46.2%)</option>
				
				<option value="file33">fund-o/api-server/internal/entity/verify_email.go (0.0%)</option>
				
				<option value="file34">fund-o/api-server/internal/entity/websocket.go (0.0%)</option>
				
				<option value="file35">fund-o/api-server/internal/http/handler/auth.go (35.7%)</option>
				
				<option value="file36">fund-o/api-server/internal/http/handler/chat.go (0.0%)</option>
				
				<option value="file37">fund-o/api-server/internal/http/handler/forum_handler.go (42.1%)</option>
				
				<option value="file38">fund-o/api-server/internal/http/handler/hello_handler.go (100.0%)</option>
				
				<option value="file39">fund-o/api-server/internal/http/handler/project_handler.go (0.0%)</option>
				
				<option value="file40">fund-o/api-server/internal/http/handler/response.go (100.0%)</option>
				
				<option value="file41">fund-o/api-server/internal/http/handler/transaction_handler.go (60.0%)</option>
				
				<option value="file42">fund-o/api-server/internal/http/handler/user.go (92.9%)</option>
				
				<option value="file43">fund-o/api-server/internal/http/middleware/authorization.go (85.3%)</option>
				
				<option value="file44">fund-o/api-server/internal/http/middleware/logger.go (0.0%)</option>
				
				<option value="file45">fund-o/api-server/internal/usecase/channel_usecase.go (0.0%)</option>
				
				<option value="file46">fund-o/api-server/internal/usecase/forum_usecase.go (58.6%)</option>
				
				<option value="file47">fund-o/api-server/internal/usecase/message_usecase.go (0.0%)</option>
				
				<option value="file48">fund-o/api-server/internal/usecase/project_category_usecase.go (0.0%)</option>
				
				<option value="file49">fund-o/api-server/internal/usecase/project_usecase.go (0.0%)</option>
				
				<option value="file50">fund-o/api-server/internal/usecase/session_usecase.go (50.0%)</option>
				
				<option value="file51">fund-o/api-server/internal/usecase/transaction_usecase.go (50.0%)</option>
				
				<option value="file52">fund-o/api-server/internal/usecase/user_usercase.go (75.0%)</option>
				
				<option value="file53">fund-o/api-server/internal/usecase/verify_email_usecase.go (0.0%)</option>
				
				<option value="file54">fund-o/api-server/mocks/mock_forum_repository.go (58.8%)</option>
				
				<option value="file55">fund-o/api-server/mocks/mock_session_repository.go (61.1%)</option>
				
				<option value="file56">fund-o/api-server/mocks/mock_task_distributor.go (25.0%)</option>
				
				<option value="file57">fund-o/api-server/mocks/mock_uploader.go (27.3%)</option>
				
				<option value="file58">fund-o/api-server/mocks/mock_user_repository.go (100.0%)</option>
				
				<option value="file59">fund-o/api-server/pkg/apperrors/apperrors.go (0.0%)</option>
				
				<option value="file60">fund-o/api-server/pkg/helper/string.go (100.0%)</option>
				
				<option value="file61">fund-o/api-server/pkg/logger/logger.go (0.0%)</option>
				
				<option value="file62">fund-o/api-server/pkg/mail/sender.go (100.0%)</option>
				
				<option value="file63">fund-o/api-server/pkg/mail/template.go (100.0%)</option>
				
				<option value="file64">fund-o/api-server/pkg/pagination/pagination.go (100.0%)</option>
				
				<option value="file65">fund-o/api-server/pkg/password/password.go (90.9%)</option>
				
				<option value="file66">fund-o/api-server/pkg/random/email.go (100.0%)</option>
				
				<option value="file67">fund-o/api-server/pkg/random/int.go (100.0%)</option>
				
				<option value="file68">fund-o/api-server/pkg/random/string.go (100.0%)</option>
				
				<option value="file69">fund-o/api-server/pkg/token/jwt_maker.go (87.5%)</option>
				
				<option value="file70">fund-o/api-server/pkg/token/payload.go (87.5%)</option>
				
				<option value="file71">fund-o/api-server/pkg/uploader/s3_store.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "fund-o/api-server/cmd/api/server"
        "fund-o/api-server/config"
        "fund-o/api-server/internal/datasource"
        "fund-o/api-server/pkg/logger"
        "github.com/gin-gonic/gin"
        "github.com/rs/zerolog/log"
)

func init() <span class="cov0" title="0">{
        logger.InitLogger()
}</span>

func main() <span class="cov0" title="0">{
        appConfig, err := config.LoadAppConfig(".")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal().Err(err).Msg("Failed to load app config")
        }</span>

        <span class="cov0" title="0">datasources := datasource.NewDatasourceContext(&amp;appConfig.DatasourceConfig)

        gin.SetMode(appConfig.GinMode)
        s := server.NewApiServer(&amp;appConfig.ApiServerConfig, datasources)
        if err := s.Start(); err != nil </span><span class="cov0" title="0">{
                log.Fatal().Err(err).Msg("Failed to start API server")
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package server

import (
        "context"
        "errors"
        "fmt"
        "fund-o/api-server/cmd/worker"
        "fund-o/api-server/cmd/ws"
        "fund-o/api-server/config"
        "fund-o/api-server/pkg/mail"
        "fund-o/api-server/pkg/uploader"
        "github.com/redis/go-redis/v9"
        "github.com/ulule/limiter/v3"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/hibiken/asynq"

        "fund-o/api-server/internal/datasource"
        "fund-o/api-server/internal/datasource/repository"
        "fund-o/api-server/internal/http/handler"
        "fund-o/api-server/internal/http/middleware"
        "fund-o/api-server/internal/usecase"
        "fund-o/api-server/pkg/token"

        "github.com/gin-gonic/gin"
        "github.com/rs/zerolog/log"

        cors "github.com/rs/cors/wrapper/gin"
        mgin "github.com/ulule/limiter/v3/drivers/middleware/gin"
        sredis "github.com/ulule/limiter/v3/drivers/store/redis"

        docs "fund-o/api-server/docs"

        swaggerfiles "github.com/swaggo/files"
        ginSwagger "github.com/swaggo/gin-swagger"
)

type ApiServer interface {
        Start() error
        HttpServer() *http.Server
}

type apiServer struct {
        httpServer *http.Server
        config     *config.ApiServerConfig
        datasource datasource.Datasource
}

func NewApiServer(config *config.ApiServerConfig, datasource datasource.Datasource) ApiServer <span class="cov0" title="0">{
        router := inject(config, datasource)

        server := &amp;http.Server{
                Addr:    fmt.Sprintf("%s:%d", config.Host, config.Port),
                Handler: router,
        }

        return &amp;apiServer{
                httpServer: server,
                config:     config,
                datasource: datasource,
        }
}</span>

func (server *apiServer) HttpServer() *http.Server <span class="cov0" title="0">{
        return server.httpServer
}</span>

func (server *apiServer) Start() error <span class="cov0" title="0">{
        log.Info().Msg("Starting listening for HTTP requests...")
        go func() </span><span class="cov0" title="0">{
                log.Info().Msgf("Server listening at http://%s:%d", server.config.Host, server.config.Port)
                log.Info().Msg("Starting listening for HTTP requests completed")
                if err := server.httpServer.ListenAndServe(); err != nil &amp;&amp; !errors.Is(err, http.ErrServerClosed) </span><span class="cov0" title="0">{
                        log.Fatal().Err(err).Msg("Failed to listen and serve")
                }</span>
        }()

        <span class="cov0" title="0">quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)

        &lt;-quit
        log.Info().Msg("Shutting down server...")

        log.Info().Msg("Unregistering datasource...")
        if err := server.datasource.Close(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error when close datasources: %v", err)
        }</span>
        <span class="cov0" title="0">log.Info().Msg("Unregistering datasource completed")

        ctx, cancel := context.WithTimeout(context.Background(), 500*time.Millisecond)
        defer cancel()

        if err := server.httpServer.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error when shutdown server: %v", err)
        }</span>

        <span class="cov0" title="0">&lt;-ctx.Done()
        log.Info().Msg("Timeout of 1 second")
        log.Info().Msg("Shutting down server completed")
        return nil</span>
}

func inject(config *config.ApiServerConfig, datasource datasource.Datasource) *gin.Engine <span class="cov0" title="0">{
        // Makers
        jwtMaker, err := token.NewJWTMaker(config.JwtSecretKey)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal().Err(err).Msg("Failed to create JWT maker")
        }</span>

        <span class="cov0" title="0">imageUploader, err := uploader.NewS3Store(&amp;uploader.S3StoreConfig{
                Region:             config.AwsRegion,
                Bucket:             config.AwsBucketName,
                AwsAccessKeyID:     config.AwsAccessKeyID,
                AwsSecretAccessKey: config.AwsSecretAccessKey,
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal().Err(err).Msg("Failed to create image uploader")
        }</span>

        // Repositories
        <span class="cov0" title="0">transactionRepository := repository.NewTransactionRepository(datasource.GetSqlDB())
        userRepository := repository.NewUserRepository(datasource.GetSqlDB())
        sessionRepository := repository.NewSessionRepository(datasource.GetSqlDB())
        projectRepository := repository.NewProjectRepository(datasource.GetSqlDB())
        projectCategoryRepository := repository.NewProjectCategoryRepository(datasource.GetSqlDB())
        verifyEmailRepository := repository.NewVerifyEmailRepository(datasource.GetSqlDB())
        forumRepository := repository.NewForumRepository(datasource.GetSqlDB())
        channelRepository := repository.NewChannelRepository(datasource.GetSqlDB())
        messageRepository := repository.NewMessageRepository(datasource.GetSqlDB())

        // UseCases
        transactionUseCase := usecase.NewTransactionUseCase(&amp;usecase.TransactionUseCaseOptions{
                TransactionRepository: transactionRepository,
        })
        userUseCase := usecase.NewUserUseCase(&amp;usecase.UserUseCaseOptions{
                UserRepository: userRepository,
                ImageUploader:  imageUploader,
        })
        sessionUseCase := usecase.NewSessionUseCase(&amp;usecase.SessionUseCaseOptions{
                SessionRepository: sessionRepository,
        })
        projectUseCase := usecase.NewProjectUseCase(&amp;usecase.ProjectUseCaseOptions{
                ProjectRepository: projectRepository,
                ImageUploader:     imageUploader,
        })
        projectCategoryUseCase := usecase.NewProjectCategoryUseCase(&amp;usecase.ProjectCategoryUseCaseOptions{
                ProjectCategoryRepository: projectCategoryRepository,
        })
        verifyEmailUseCase := usecase.NewVerifyEmailUseCase(&amp;usecase.VerifyEmailUseCaseOptions{
                VerifyEmailRepository: verifyEmailRepository,
        })
        forumUseCase := usecase.NewForumUseCase(&amp;usecase.ForumUseCaseOptions{
                ForumRepository: forumRepository,
                ImageUploader:   imageUploader,
        })
        channelUsecase := usecase.NewChannelUsecase(&amp;usecase.ChannelUsecaseOptions{
                ChannelRepository: channelRepository,
        })
        messageUseCase := usecase.NewMessageUsecase(&amp;usecase.MessageUsecaseOptions{
                MessageRepository: messageRepository,
                ImageUploader:     imageUploader,
        })

        // Task Processor
        redisOptions := asynq.RedisClientOpt{
                Addr: config.RedisAddress,
        }
        taskDistributor := worker.NewRedisTaskDistributor(redisOptions)
        gmailOptions := mail.GmailSenderOptions{
                Name:              config.EmailSenderName,
                FromEmailAddress:  config.EmailSenderAddress,
                FromEmailPassword: config.EmailSenderPassword,
        }
        go runTaskProcessor(redisOptions, gmailOptions, &amp;worker.TaskProcessorUseCaseOptions{
                UserUseCase:        userUseCase,
                VerifyEmailUseCase: verifyEmailUseCase,
        })

        // Redis
        redisClient := redis.NewClient(&amp;redis.Options{
                Addr: config.RedisAddress,
        })

        // Websocket
        hub := ws.NewWebsocketHub(&amp;ws.Config{
                Redis: redisClient,
        })
        go hub.Run()
        socketService := ws.NewSocketService(&amp;ws.SocketServiceConfig{
                Hub: hub,
        })

        // Handlers
        transactionHandler := handler.NewTransactionHandler(&amp;handler.TransactionHandlerOptions{
                TransactionUseCase: transactionUseCase,
        })
        authHandler := handler.NewAuthHandler(&amp;handler.AuthHandlerOptions{
                UserUseCase:        userUseCase,
                SessionUseCase:     sessionUseCase,
                VerifyEmailUseCase: verifyEmailUseCase,
                TokenMaker:         jwtMaker,
                TaskDistributor:    taskDistributor,
        })
        userHandler := handler.NewUserHandler(&amp;handler.UserHandlerOptions{
                UserUseCase: userUseCase,
        })
        projectHandler := handler.NewProjectHandler(&amp;handler.ProjectHandlerOptions{
                ProjectUseCase:         projectUseCase,
                UserUseCase:            userUseCase,
                ProjectCategoryUseCase: projectCategoryUseCase,
        })
        forumHandler := handler.NewForumHandler(&amp;handler.ForumHandlerOptions{
                ForumUseCase: forumUseCase,
        })
        chatHandler := handler.NewChatHandler(&amp;handler.ChatHandlerOptions{
                ChannelUsecase: channelUsecase,
                MessageUsecase: messageUseCase,
                SocketService:  socketService,
        })

        authMiddleware := middleware.AuthMiddleware(jwtMaker)

        router := gin.New()

        c := cors.New(cors.Options{
                AllowedOrigins:   []string{config.CorsAllowedOrigin},
                AllowCredentials: config.CorsAllowedCredentials,
                AllowedMethods:   []string{"GET", "POST", "PUT", "PATCH", "DELETE"},
        })
        router.Use(c)

        router.Use(middleware.RequestLogger())
        router.Use(middleware.ResponseLogger())
        router.Use(registerRateLimiter(redisClient))

        router.GET("/ws", authMiddleware, func(c *gin.Context) </span><span class="cov0" title="0">{
                ws.ServeWs(hub, c)
        }</span>)

        <span class="cov0" title="0">routeV1 := router.Group(config.PathPrefix)

        docs.SwaggerInfo.BasePath = config.PathPrefix
        initSwaggerDocs(routeV1)

        // Routes
        routeV1.GET("/hello", handler.GetHelloMessage)
        transactionRoute := routeV1.Group("/transactions")
        </span><span class="cov0" title="0">{
                transactionRoute.GET("", transactionHandler.ListTransactions)
                transactionRoute.GET("/:id", transactionHandler.GetTransaction)
                transactionRoute.POST("", transactionHandler.CreateTransaction)
        }</span>
        <span class="cov0" title="0">authRoute := routeV1.Group("/auth")
        </span><span class="cov0" title="0">{
                authRoute.POST("/register", authHandler.Register)
                authRoute.POST("/login", authHandler.Login)
                authRoute.POST("/renew-token", authHandler.RenewAccessToken)
                authRoute.GET("/verify-email", authHandler.VerifyEmail)
                authRoute.POST("/send-verify-email", authHandler.SendVerifyEmail)
                // authRoute.POST("/login-with-google", func(c *gin.Context) {
                //         c.Redirect(http.StatusTemporaryRedirect, )
                // })
        }</span>
        <span class="cov0" title="0">userRoute := routeV1.Group("/users")
        </span><span class="cov0" title="0">{
                userRoute.GET("/me", authMiddleware, userHandler.GetMe)
                userRoute.PATCH("/:id", authMiddleware, userHandler.UpdateUser)
        }</span>
        <span class="cov0" title="0">projectRoute := routeV1.Group("/projects")
        </span><span class="cov0" title="0">{
                projectRoute.GET("", projectHandler.ListProjects)
                projectRoute.POST("", authMiddleware, projectHandler.CreateProject)
                projectRoute.GET("/:id", projectHandler.GetProjectByID)
                projectRoute.GET("/me", authMiddleware, projectHandler.GetOwnProjects)
                projectRoute.GET("/recommendation", projectHandler.GetRecommendProjects)
                projectRoute.GET("/categories", projectHandler.ListProjectCategories)
                projectRoute.POST("/:id/ratings", authMiddleware, projectHandler.CreateProjectRating)
                projectRoute.GET("/:id/ratings/verify", authMiddleware, projectHandler.VerifyProjectRating)
                projectRoute.POST("/:id/contribute", authMiddleware, projectHandler.ContributeProject)
                projectRoute.GET("/backed", authMiddleware, projectHandler.GetBackedProject)
        }</span>
        <span class="cov0" title="0">postRoute := routeV1.Group("/posts")
        </span><span class="cov0" title="0">{
                postRoute.GET("", forumHandler.ListPosts)
                postRoute.POST("", authMiddleware, forumHandler.CreatePost)
                postRoute.GET("/:id", forumHandler.GetPostByID)
                postRoute.POST("/:id/comments", authMiddleware, forumHandler.CreateComment)
                postRoute.POST("/upload", authMiddleware, forumHandler.UploadImage)
        }</span>
        <span class="cov0" title="0">commentRoute := routeV1.Group("/comments")
        </span><span class="cov0" title="0">{
                commentRoute.POST("/:id/replies", authMiddleware, forumHandler.CreateReply)
        }</span>
        <span class="cov0" title="0">channelRoute := routeV1.Group("/channels")
        </span><span class="cov0" title="0">{
                channelRoute.GET("/me", authMiddleware, chatHandler.GetOwnChannels)
                channelRoute.GET("/:id", authMiddleware, chatHandler.GetOrCreateChannel)
                channelRoute.POST("/:id/messages", authMiddleware, chatHandler.SendMessage)
        }</span>

        <span class="cov0" title="0">return router</span>
}

// @title FundO API
// @version 1.0
// @description This is a sample server.
// @termsOfService http://swagger.io/terms/

// @contact.name API Support
// @contact.url http://www.swagger.io/support
// @contact.email support@swagger.io

// @license.name Apache 2.0
// @license.url http://www.apache.org/licenses/LICENSE-2.0.html

// @schemes http https

// @securityDefinitions.apikey ApiKeyAuth
// @in header
// @name Authorization
func initSwaggerDocs(router *gin.RouterGroup) <span class="cov0" title="0">{
        router.GET("/openapi/*any", ginSwagger.WrapHandler(swaggerfiles.Handler))
}</span>

func registerRateLimiter(redisClient *redis.Client) gin.HandlerFunc <span class="cov0" title="0">{
        rate, err := limiter.NewRateFromFormatted("5-S")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal().Err(err).Msg("failed to create rate limiter")
        }</span>

        <span class="cov0" title="0">store, err := sredis.NewStoreWithOptions(redisClient, limiter.StoreOptions{
                Prefix: "limiter_fundo",
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal().Err(err).Msg("failed to create rate limiter store")
        }</span>

        <span class="cov0" title="0">rateLimitMiddleware := mgin.NewMiddleware(limiter.New(store, rate))
        return rateLimitMiddleware</span>
}

func runTaskProcessor(
        redisOptions asynq.RedisClientOpt,
        gmailOptions mail.GmailSenderOptions,
        useCases *worker.TaskProcessorUseCaseOptions,
) <span class="cov0" title="0">{
        mailer := mail.NewGmailSender(&amp;gmailOptions)
        taskProcessor := worker.NewRedisTaskProcessor(&amp;worker.RedisTaskProcessorOptions{
                RedisOptions: redisOptions,
                Mailer:       mailer,
                UseCases:     useCases,
        })

        err := taskProcessor.Start()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal().Err(err).Msg("failed to start task processor")
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package worker

import (
        "context"

        "github.com/hibiken/asynq"
)

type TaskDistributor interface {
        DistributeTaskSendVerifyEmail(
                ctx context.Context,
                payload *PayloadSendVerifyEmail,
                opts ...asynq.Option,
        )
}

type RedisTaskDistributor struct {
        client *asynq.Client
        logger *Logger
}

func NewRedisTaskDistributor(redisOpt asynq.RedisClientOpt) TaskDistributor <span class="cov0" title="0">{
        client := asynq.NewClient(redisOpt)
        logger := NewWorkerLogger("distributor")

        return &amp;RedisTaskDistributor{
                client: client,
                logger: logger,
        }
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package worker

import (
        "context"
        "fmt"
        "os"
        "time"

        "github.com/rs/zerolog"
        "github.com/rs/zerolog/log"
)

type Logger struct {
        log zerolog.Logger
}

func NewWorkerLogger(role string) *Logger <span class="cov0" title="0">{
        output := zerolog.ConsoleWriter{
                Out:        os.Stdout,
                TimeFormat: time.RFC3339,
                FormatCaller: func(i interface{}) string </span><span class="cov0" title="0">{
                        return "[worker]"
                }</span>,
        }

        <span class="cov0" title="0">log := zerolog.New(output).With().Timestamp().Str("role", role).Logger()
        return &amp;Logger{log}</span>
}

func (logger *Logger) Print(level zerolog.Level, args ...interface{}) <span class="cov0" title="0">{
        logger.log.WithLevel(level).Msg(fmt.Sprint(args...))
}</span>

func (logger *Logger) Printf(ctx context.Context, format string, v ...interface{}) <span class="cov0" title="0">{
        log.WithLevel(zerolog.DebugLevel).Msgf(format, v...)
}</span>

func (logger *Logger) Debug(args ...interface{}) <span class="cov0" title="0">{
        logger.Print(zerolog.DebugLevel, args...)
}</span>

func (logger *Logger) Info(args ...interface{}) <span class="cov0" title="0">{
        logger.Print(zerolog.InfoLevel, args...)
}</span>

func (logger *Logger) Warn(args ...interface{}) <span class="cov0" title="0">{
        logger.Print(zerolog.WarnLevel, args...)
}</span>

func (logger *Logger) Error(args ...interface{}) <span class="cov0" title="0">{
        logger.Print(zerolog.ErrorLevel, args...)
}</span>

func (logger *Logger) Fatal(args ...interface{}) <span class="cov0" title="0">{
        logger.Print(zerolog.FatalLevel, args...)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package worker

import (
        "context"
        "fund-o/api-server/internal/usecase"
        "fund-o/api-server/pkg/mail"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/hibiken/asynq"
        "github.com/redis/go-redis/v9"
)

const (
        QueueCritical = "critical"
        QueueDefault  = "default"
)

type TaskProcessor interface {
        Start() error
        ProcessTaskSendVerifyEmail(ctx context.Context, task *asynq.Task) error
}

type RedisTaskProcessor struct {
        server   *asynq.Server
        mailer   mail.EmailSender
        useCases *TaskProcessorUseCaseOptions
        logger   *Logger
}

type RedisTaskProcessorOptions struct {
        RedisOptions asynq.RedisClientOpt
        Mailer       mail.EmailSender
        UseCases     *TaskProcessorUseCaseOptions
}

type TaskProcessorUseCaseOptions struct {
        UserUseCase        usecase.UserUseCase
        VerifyEmailUseCase usecase.VerifyEmailUseCase
}

func NewRedisTaskProcessor(options *RedisTaskProcessorOptions) TaskProcessor <span class="cov0" title="0">{
        logger := NewWorkerLogger("processor")
        redis.SetLogger(logger)

        server := asynq.NewServer(
                asynq.RedisClientOpt{},
                asynq.Config{
                        Queues: map[string]int{
                                QueueCritical: 10,
                                QueueDefault:  5,
                        },
                        ErrorHandler: asynq.ErrorHandlerFunc(func(ctx context.Context, task *asynq.Task, err error) </span><span class="cov0" title="0">{
                                logger.log.Error().Err(err).
                                        Str("type", task.Type()).
                                        Bytes("payload", task.Payload()).
                                        Msg("process task failed")
                        }</span>),
                        Logger: logger,
                },
        )

        <span class="cov0" title="0">return &amp;RedisTaskProcessor{
                server: server,
                mailer: options.Mailer,
                useCases: &amp;TaskProcessorUseCaseOptions{
                        UserUseCase:        options.UseCases.UserUseCase,
                        VerifyEmailUseCase: options.UseCases.VerifyEmailUseCase,
                },
                logger: logger,
        }</span>
}

func (processor *RedisTaskProcessor) Start() error <span class="cov0" title="0">{
        log := processor.logger.log

        mux := asynq.NewServeMux()
        mux.HandleFunc(TaskSendVerifyEmail, processor.ProcessTaskSendVerifyEmail)

        log.Info().Msg("Starting task processor...")
        go func() </span><span class="cov0" title="0">{
                err := processor.server.Start(mux)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal().Err(err).Msg("failed to start task processor")
                }</span>
        }()

        <span class="cov0" title="0">quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)

        &lt;-quit
        log.Info().Msg("Shutting down task processor...")

        ctx, cancel := context.WithTimeout(context.Background(), 200*time.Millisecond)
        defer cancel()

        processor.server.Shutdown()
        &lt;-ctx.Done()

        return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package worker

import (
        "context"
        "encoding/json"
        "fmt"
        "fund-o/api-server/internal/entity"
        "fund-o/api-server/pkg/mail"
        "fund-o/api-server/pkg/random"

        "github.com/hibiken/asynq"
)

const TaskSendVerifyEmail = "task:send_verify_email"

type PayloadSendVerifyEmail struct {
        Email string `json:"email"`
}

func (distributor *RedisTaskDistributor) DistributeTaskSendVerifyEmail(
        ctx context.Context,
        payload *PayloadSendVerifyEmail,
        opts ...asynq.Option,
) <span class="cov0" title="0">{
        log := distributor.logger.log
        jsonPayload, err := json.Marshal(payload)
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Err(err).Msg("failed to marshal task payload")
        }</span>

        <span class="cov0" title="0">task := asynq.NewTask(TaskSendVerifyEmail, jsonPayload, opts...)
        info, err := distributor.client.EnqueueContext(ctx, task)
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Err(err).Msg("failed to enqueue task")
        }</span>

        <span class="cov0" title="0">log.Info().
                Str("type", task.Type()).
                Bytes("payload", task.Payload()).
                Str("queue", info.Queue).
                Int("max_retry", info.MaxRetry).
                Msg("enqueued task")</span>
}

func (processor *RedisTaskProcessor) ProcessTaskSendVerifyEmail(_ context.Context, task *asynq.Task) error <span class="cov0" title="0">{
        var payload PayloadSendVerifyEmail
        if err := json.Unmarshal(task.Payload(), &amp;payload); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unmarshal payload: %w", asynq.SkipRetry)
        }</span>

        <span class="cov0" title="0">user, err := processor.useCases.UserUseCase.GetUserByEmail(payload.Email)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get user: %w", err)
        }</span>

        <span class="cov0" title="0">verifyEmail, err := processor.useCases.VerifyEmailUseCase.CreateVerifyEmail(&amp;entity.VerifyEmailCreatePayload{
                Email:      user.Email,
                SecretCode: random.NewString(32),
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create verify email: %w", err)
        }</span>

        <span class="cov0" title="0">subject := "Welcome to Simple Bank"
        // TODO: replace this URL with an environment variable that points to a front-end page

        host := "http://localhost:3000/api/v1"
        verifyUrl := fmt.Sprintf("%s/auth/verify-email?email_id=%s&amp;secret_code=%s", host, verifyEmail.ID, verifyEmail.SecretCode)
        content := mail.NewVerifyEmailTemplate(verifyUrl)
        to := []string{user.Email}

        err = processor.mailer.SendEmail(subject, content, to, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to send verify email: %w", err)
        }</span>

        <span class="cov0" title="0">processor.logger.log.Info().
                Str("type", task.Type()).
                Bytes("payload", task.Payload()).
                Str("email", user.Email).
                Msg("processed task")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package ws

import (
        "encoding/json"
        "fmt"
        "fund-o/api-server/internal/entity"
        "fund-o/api-server/internal/http/middleware"
        "fund-o/api-server/pkg/token"
        "github.com/gin-gonic/gin"
        "log"
        "net/http"
        "time"

        "github.com/gorilla/websocket"
)

const (
        writeWait      = 10 * time.Second
        pongWait       = 60 * time.Second
        pingPeriod     = (pongWait * 9) / 10
        maxMessageSize = 10000
)

var newline = []byte{'\n'}

var upgrader = websocket.Upgrader{
        ReadBufferSize:  4096,
        WriteBufferSize: 4096,
        CheckOrigin: func(r *http.Request) bool <span class="cov0" title="0">{
                return true
        }</span>,
}

// Client represents the websockets client at the server
type Client struct {
        // The actual websockets connection.
        ID    string
        conn  *websocket.Conn
        hub   *Hub
        send  chan []byte
        rooms map[*Room]bool
}

func newClient(conn *websocket.Conn, hub *Hub, id string) *Client <span class="cov0" title="0">{
        return &amp;Client{
                ID:    id,
                conn:  conn,
                hub:   hub,
                send:  make(chan []byte, 256),
                rooms: make(map[*Room]bool),
        }
}</span>

func (client *Client) readPump() <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                client.disconnect()
        }</span>()

        <span class="cov0" title="0">client.conn.SetReadLimit(maxMessageSize)

        _ = client.conn.SetReadDeadline(time.Now().Add(pongWait))

        client.conn.SetPongHandler(func(string) error </span><span class="cov0" title="0">{
                _ = client.conn.SetReadDeadline(time.Now().Add(pongWait))
                return nil
        }</span>)

        // Start endless read loop, waiting for messages from client
        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                _, jsonMessage, err := client.conn.ReadMessage()
                if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">client.handleNewMessage(jsonMessage)</span>
        }

}

func (client *Client) writePump() <span class="cov0" title="0">{
        ticker := time.NewTicker(pingPeriod)
        defer func() </span><span class="cov0" title="0">{
                ticker.Stop()
                _ = client.conn.Close()
        }</span>()
        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                select </span>{
                case message, ok := &lt;-client.send:<span class="cov0" title="0">
                        _ = client.conn.SetWriteDeadline(time.Now().Add(writeWait))
                        if !ok </span><span class="cov0" title="0">{
                                // The hub closed the channel.
                                _ = client.conn.WriteMessage(websocket.CloseMessage, []byte{})
                                return
                        }</span>

                        <span class="cov0" title="0">w, err := client.conn.NextWriter(websocket.TextMessage)
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">_, _ = w.Write(message)

                        // Attach queued chat messages to the current websockets message.
                        n := len(client.send)
                        for i := 0; i &lt; n; i++ </span><span class="cov0" title="0">{
                                _, _ = w.Write(newline)
                                _, _ = w.Write(&lt;-client.send)
                        }</span>

                        <span class="cov0" title="0">if err := w.Close(); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        _ = client.conn.SetWriteDeadline(time.Now().Add(writeWait))
                        if err := client.conn.WriteMessage(websocket.PingMessage, nil); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }
}

func (client *Client) disconnect() <span class="cov0" title="0">{
        client.hub.unregister &lt;- client
        for room := range client.rooms </span><span class="cov0" title="0">{
                room.unregister &lt;- client
        }</span>
        <span class="cov0" title="0">close(client.send)
        _ = client.conn.Close()</span>
}

// ServeWs handles websockets requests from clients requests.
func ServeWs(hub *Hub, ctx *gin.Context) <span class="cov0" title="0">{
        userID := ctx.MustGet(middleware.AuthorizationPayloadKey).(*token.Payload).UserID
        conn, err := upgrader.Upgrade(ctx.Writer, ctx.Request, nil)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err)
                return
        }</span>

        <span class="cov0" title="0">client := newClient(conn, hub, userID)

        go client.writePump()
        go client.readPump()

        hub.register &lt;- client</span>
}

func (client *Client) handleNewMessage(jsonMessage []byte) <span class="cov0" title="0">{
        var message entity.ReceivedMessage
        if err := json.Unmarshal(jsonMessage, &amp;message); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error on unmarshal JSON message %s", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Received message: %+v\n", message)

        switch message.Action </span>{
        case JoinUserAction:<span class="cov0" title="0">
                client.handleJoinRoomMessage(message)</span>
        case LeaveUserAction:<span class="cov0" title="0">
                client.handleLeaveRoomMessage(message)</span>
        }
}

func (client *Client) handleJoinRoomMessage(message entity.ReceivedMessage) <span class="cov0" title="0">{
        roomName := message.Room

        room := client.hub.findRoomById(roomName)
        if room == nil </span><span class="cov0" title="0">{
                room = client.hub.createRoom(roomName)
        }</span>

        <span class="cov0" title="0">client.rooms[room] = true

        room.register &lt;- client</span>
}

func (client *Client) handleLeaveRoomMessage(message entity.ReceivedMessage) <span class="cov0" title="0">{
        roomName := message.Room

        room := client.hub.findRoomById(roomName)
        if room == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">delete(client.rooms, room)

        room.unregister &lt;- client</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package ws

import "github.com/redis/go-redis/v9"

type Hub struct {
        clients     map[*Client]bool
        register    chan *Client
        unregister  chan *Client
        broadcast   chan []byte
        rooms       map[*Room]bool
        redisClient *redis.Client
}

type Config struct {
        Redis *redis.Client
}

func NewWebsocketHub(c *Config) *Hub <span class="cov0" title="0">{
        return &amp;Hub{
                clients:     make(map[*Client]bool),
                register:    make(chan *Client),
                unregister:  make(chan *Client),
                broadcast:   make(chan []byte),
                rooms:       make(map[*Room]bool),
                redisClient: c.Redis,
        }
}</span>

// Run our websocket server, accepting various requests
func (hub *Hub) Run() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                select </span>{
                case client := &lt;-hub.register:<span class="cov0" title="0">
                        hub.registerClient(client)</span>
                case client := &lt;-hub.unregister:<span class="cov0" title="0">
                        hub.unregisterClient(client)</span>
                case message := &lt;-hub.broadcast:<span class="cov0" title="0">
                        hub.broadcastToClients(message)</span>
                }
        }
}

func (hub *Hub) registerClient(client *Client) <span class="cov0" title="0">{
        hub.clients[client] = true
}</span>

func (hub *Hub) unregisterClient(client *Client) <span class="cov0" title="0">{
        delete(hub.clients, client)
}</span>

func (hub *Hub) broadcastToClients(message []byte) <span class="cov0" title="0">{
        for client := range hub.clients </span><span class="cov0" title="0">{
                client.send &lt;- message
        }</span>
}

// BroadcastToRoom sends the given message to all clients connected to the given room
func (hub *Hub) BroadcastToRoom(message []byte, roomId string) <span class="cov0" title="0">{
        if room := hub.findRoomById(roomId); room != nil </span><span class="cov0" title="0">{
                room.publishRoomMessage(message)
        }</span>
}

func (hub *Hub) findRoomById(id string) *Room <span class="cov0" title="0">{
        var foundRoom *Room
        for room := range hub.rooms </span><span class="cov0" title="0">{
                if room.GetId() == id </span><span class="cov0" title="0">{
                        foundRoom = room
                        break</span>
                }
        }

        <span class="cov0" title="0">return foundRoom</span>
}

func (hub *Hub) createRoom(id string) *Room <span class="cov0" title="0">{
        room := NewRoom(id, hub.redisClient)
        go room.RunRoom()
        hub.rooms[room] = true

        return room
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package ws

import (
        "context"
        "fund-o/api-server/internal/entity"
        "github.com/redis/go-redis/v9"
        "log"
)

// Room represents a websocket room
type Room struct {
        id         string
        clients    map[*Client]bool
        register   chan *Client
        unregister chan *Client
        broadcast  chan *entity.WebsocketMessage
        redis      *redis.Client
}

var ctx = context.Background()

// NewRoom creates a new Room
func NewRoom(id string, rds *redis.Client) *Room <span class="cov0" title="0">{
        return &amp;Room{
                id:         id,
                clients:    make(map[*Client]bool),
                register:   make(chan *Client),
                unregister: make(chan *Client),
                broadcast:  make(chan *entity.WebsocketMessage),
                redis:      rds,
        }
}</span>

// RunRoom runs our room, accepting various requests
func (room *Room) RunRoom() <span class="cov0" title="0">{
        go room.subscribeToRoomMessages()

        for </span><span class="cov0" title="0">{
                select </span>{
                case client := &lt;-room.register:<span class="cov0" title="0">
                        room.registerClientInRoom(client)</span>
                case client := &lt;-room.unregister:<span class="cov0" title="0">
                        room.unregisterClientInRoom(client)</span>
                case message := &lt;-room.broadcast:<span class="cov0" title="0">
                        room.publishRoomMessage(message.Encode())</span>
                }
        }
}

// registerClientInRoom adds the client to the room
func (room *Room) registerClientInRoom(client *Client) <span class="cov0" title="0">{
        room.clients[client] = true
}</span>

// unregisterClientInRoom removes the client from the room
func (room *Room) unregisterClientInRoom(client *Client) <span class="cov0" title="0">{
        delete(room.clients, client)
}</span>

// broadcastToClientsInRoom sends the given message to all members in the room
func (room *Room) broadcastToClientsInRoom(message []byte) <span class="cov0" title="0">{
        for client := range room.clients </span><span class="cov0" title="0">{
                client.send &lt;- message
        }</span>
}

// GetId returns the ID of the room
func (room *Room) GetId() string <span class="cov0" title="0">{
        return room.id
}</span>

// publishRoomMessage publishes the message to all clients subscribing to the room
func (room *Room) publishRoomMessage(message []byte) <span class="cov0" title="0">{
        err := room.redis.Publish(ctx, room.GetId(), message).Err()

        if err != nil </span><span class="cov0" title="0">{
                log.Println(err)
        }</span>
}

// subscribeToRoomMessages subscribes to messages in this room
func (room *Room) subscribeToRoomMessages() <span class="cov0" title="0">{
        pubSub := room.redis.Subscribe(ctx, room.GetId())

        ch := pubSub.Channel()

        for msg := range ch </span><span class="cov0" title="0">{
                room.broadcastToClientsInRoom([]byte(msg.Payload))
        }</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package ws

import (
        "encoding/json"
        "fmt"
        "fund-o/api-server/internal/entity"
        "github.com/rs/zerolog/log"
)

type SocketService interface {
        EmitNewMessage(room string, message *entity.MessageDto)
}

type socketService struct {
        hub *Hub
}

type SocketServiceConfig struct {
        *Hub
}

func NewSocketService(config *SocketServiceConfig) SocketService <span class="cov0" title="0">{
        return &amp;socketService{
                hub: config.Hub,
        }
}</span>

func (s *socketService) EmitNewMessage(room string, message *entity.MessageDto) <span class="cov0" title="0">{
        data, err := json.Marshal(entity.WebsocketMessage{
                Action: NewMessageAction,
                Data:   message,
        })

        if err != nil </span><span class="cov0" title="0">{
                log.Error().Err(err).Msg("error marshalling response")
        }</span>

        <span class="cov0" title="0">fmt.Println("Broadcasting to room: ", room, string(data))
        s.hub.BroadcastToRoom(data, room)</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package config

import (
        "fund-o/api-server/internal/datasource"
        "github.com/spf13/viper"
)

type AppConfig struct {
        AppEnv   string `mapstructure:"APP_ENV"`
        LogLevel string `mapstructure:"LOG_LEVEL"`
        GinMode  string `mapstructure:"GIN_MODE"`
        ApiServerConfig
        datasource.DatasourceConfig
}

func LoadAppConfig(path string) (config AppConfig, err error) <span class="cov8" title="1">{
        makeDefaultAppConfig()
        //viper.AddConfigPath(path)
        viper.AddConfigPath(path)
        viper.SetConfigName(".env")
        viper.SetConfigType("env")

        //viper.SetConfigFile(".env")

        viper.AutomaticEnv()

        err = viper.ReadInConfig()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">err = viper.Unmarshal(&amp;config)
        return</span>
}

func makeDefaultAppConfig() <span class="cov8" title="1">{
        // Set default values for app configuration
        viper.SetDefault("APP_ENV", "development")
        viper.SetDefault("LOG_REQUEST", true)
        viper.SetDefault("GIN_MODE", "debug")

        // Set default values for api server configuration
        viper.SetDefault("ApiServerConfig.APP_HOST", "localhost")
        viper.SetDefault("ApiServerConfig.APP_PORT", "3000")
        viper.SetDefault("ApiServerConfig.APP_PATH_PREFIX", "/api/v1")
        viper.SetDefault("ApiServerConfig.APP_REQUEST_ID_HEADER", "X-Request-Id")
        viper.SetDefault("ApiServerConfig.APP_TRUST_PROXY", "10.0.0.0/8,172.16.0.0/12,192.168.0.0/16,fd00::/8")
        viper.SetDefault("ApiServerConfig.APP_CORS_ENABLED", true)
        viper.SetDefault("ApiServerConfig.APP_CORS_ALLOWED_ORIGIN", "*")
        viper.SetDefault("ApiServerConfig.APP_CORS_ALLOWED_CREDENTIALS", true)
        viper.SetDefault("ApiServerConfig.APP_CORS_MAX_AGE", 300)
        viper.SetDefault("ApiServerConfig.APP_READ_ONLY", false)
        viper.SetDefault("ApiServerConfig.LOG_REQUEST", true)

        // Set default values for sql db configuration
        viper.SetDefault("DatasourceConfig.SqlDBConfig.SQL_HOST", "localhost")
        viper.SetDefault("DatasourceConfig.SqlDBConfig.SQL_USERNAME", "docker")
        viper.SetDefault("DatasourceConfig.SqlDBConfig.SQL_PASSWORD", "secret")
        viper.SetDefault("DatasourceConfig.SqlDBConfig.SQL_PORT", 5432)
        viper.SetDefault("DatasourceConfig.SqlDBConfig.SQL_DATABASE", "fundo")
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "termsOfService": "http://swagger.io/terms/",
        "contact": {
            "name": "API Support",
            "url": "http://www.swagger.io/support",
            "email": "support@swagger.io"
        },
        "license": {
            "name": "Apache 2.0",
            "url": "http://www.apache.org/licenses/LICENSE-2.0.html"
        },
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/auth/login": {
            "post": {
                "description": "Authenticate user with email and password",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "Authenticate User",
                "operationId": "Login",
                "parameters": [
                    {
                        "description": "User data to be authenticated",
                        "name": "User",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/UserLoginPayload"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/ResultResponse-UserAuthenticateResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/ErrorResponse"
                        }
                    }
                }
            }
        },
        "/auth/register": {
            "post": {
                "description": "Create user with specific user data and role",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "Register User",
                "operationId": "Register",
                "parameters": [
                    {
                        "description": "User data to be created",
                        "name": "User",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/UserCreatePayload"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/ResultResponse-UserAuthenticateResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/ErrorResponse"
                        }
                    }
                }
            }
        },
        "/auth/renew-token": {
            "post": {
                "description": "Renew access token with refresh token",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "Renew Access Token",
                "operationId": "RenewAccessToken",
                "parameters": [
                    {
                        "description": "Refresh token to be renewed",
                        "name": "User",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/internal_http_handler.RenewAccessTokenPayload"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/ResultResponse-internal_http_handler_RenewAccessTokenResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/ErrorResponse"
                        }
                    }
                }
            }
        },
        "/auth/send-verify-email": {
            "post": {
                "description": "Send verify email to user email",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "Send Verify Email",
                "operationId": "SendVerifyEmail",
                "parameters": [
                    {
                        "description": "User email to be verified",
                        "name": "User",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/internal_http_handler.SendVerifyEmailPayload"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/MessageResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/ErrorResponse"
                        }
                    }
                }
            }
        },
        "/auth/verify-email": {
            "get": {
                "description": "Verify email with email id and secret code",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "Verify Email",
                "operationId": "VerifyEmail",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Email ID to be verified",
                        "name": "email_id",
                        "in": "query",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Secret Code to be verified",
                        "name": "secret_code",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/ResultResponse-User"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/ErrorResponse"
                        }
                    }
                }
            }
        },
        "/comments/{id}/replies": {
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Create reply for comment",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "forums"
                ],
                "summary": "Create Reply",
                "operationId": "CreateReply",
                "parameters": [
                    {
                        "type": "string",
                        "description": "comment id to reply",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "reply payload",
                        "name": "payload",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/fund-o_api-server_internal_entity.ReplyCreatePayload"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/ResultResponse-Reply"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/ErrorResponse"
                        }
                    }
                }
            }
        },
        "/hello": {
            "get": {
                "description": "Health checking for the service",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "healthcheck"
                ],
                "summary": "Health Check",
                "operationId": "GetHelloMessageHandler",
                "parameters": [
                    {
                        "type": "string",
                        "description": "name of the active user",
                        "name": "name",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/MessageResponse"
                        }
                    }
                }
            }
        },
        "/posts": {
            "get": {
                "description": "List posts",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "forums"
                ],
                "summary": "List Posts",
                "operationId": "ListPosts",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "number of page",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "size of data per page",
                        "name": "size",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/ResultResponse-PaginateResult-Post"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/ErrorResponse"
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Create post",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "forums"
                ],
                "summary": "Create Post",
                "operationId": "CreatePost",
                "parameters": [
                    {
                        "description": "post payload",
                        "name": "payload",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/fund-o_api-server_internal_entity.PostCreatePayload"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/ResultResponse-Post"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/ErrorResponse"
                        }
                    }
                }
            }
        },
        "/posts/upload": {
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Upload post image",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "forums"
                ],
                "summary": "Upload Post Image",
                "operationId": "UploadImage",
                "parameters": [
                    {
                        "type": "file",
                        "description": "post image file",
                        "name": "image",
                        "in": "formData",
                        "required": true
                    }
                ],
                "responses": {
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/ErrorResponse"
                        }
                    }
                }
            }
        },
        "/posts/{id}": {
            "get": {
                "description": "Get post by id",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "forums"
                ],
                "summary": "Get Post by ID",
                "operationId": "GetPostByID",
                "parameters": [
                    {
                        "type": "string",
                        "description": "post id to get",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/ResultResponse-Post"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/ErrorResponse"
                        }
                    }
                }
            }
        },
        "/posts/{id}/comments": {
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Create comment for forum",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "forums"
                ],
                "summary": "Create Comment",
                "operationId": "CreateComment",
                "parameters": [
                    {
                        "type": "string",
                        "description": "forum id to comment",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "comment payload",
                        "name": "payload",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/fund-o_api-server_internal_entity.CommentCreatePayload"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/ResultResponse-Comment"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/ErrorResponse"
                        }
                    }
                }
            }
        },
        "/projects": {
            "get": {
                "description": "List projects",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "projects"
                ],
                "summary": "List Projects",
                "operationId": "ListProjects",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "number of page",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "size of data per page",
                        "name": "size",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/ResultResponse-PaginateResult-Project"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/ErrorResponse"
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Create project with required data",
                "consumes": [
                    "multipart/form-data"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "projects"
                ],
                "summary": "Create Project",
                "operationId": "CreateProject",
                "parameters": [
                    {
                        "description": "Project data to be created",
                        "name": "Project",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/fund-o_api-server_internal_entity.ProjectCreatePayload"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/ResultResponse-Project"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/ErrorResponse"
                        }
                    }
                }
            }
        },
        "/projects/categories": {
            "get": {
                "description": "List project categories for selection",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "projects"
                ],
                "summary": "List Project Categories",
                "operationId": "ListProjectCategories",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/ResultResponse-array_ProjectCategory"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/ErrorResponse"
                        }
                    }
                }
            }
        },
        "/projects/me": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Get own projects with authenticate creator",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "projects"
                ],
                "summary": "Get own Projects",
                "operationId": "GetOwnProjects",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/ResultResponse-array_Project"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/ErrorResponse"
                        }
                    }
                }
            }
        },
        "/projects/{id}": {
            "get": {
                "description": "Get project by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "projects"
                ],
                "summary": "Get Project by ID",
                "operationId": "GetProjectByID",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Project ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/ResultResponse-Project"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/ErrorResponse"
                        }
                    }
                }
            }
        },
        "/projects/{id}/ratings": {
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Create project rating with required data",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "projects"
                ],
                "summary": "Create Project Rating",
                "operationId": "CreateProjectRating",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Project ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Project rating data to be created",
                        "name": "ProjectRating",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/fund-o_api-server_internal_entity.ProjectRatingCreatePayload"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/ResultResponse-Project"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/ErrorResponse"
                        }
                    }
                }
            }
        },
        "/projects/{id}/ratings/verify": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Verify project rating by user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "projects"
                ],
                "summary": "Verify Project Rating",
                "operationId": "VerifyProjectRating",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Project ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/ResultResponse-bool"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/ErrorResponse"
                        }
                    }
                }
            }
        },
        "/transactions": {
            "get": {
                "description": "Get list of transactions",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "transasctions"
                ],
                "summary": "List Transaction",
                "operationId": "ListTransactions",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "number of page",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "size of data per page",
                        "name": "size",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/ResultResponse-PaginateResult-Transaction"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/ErrorResponse"
                        }
                    }
                }
            },
            "post": {
                "description": "Create transaction with reference code",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "transasctions"
                ],
                "summary": "Create Transaction",
                "operationId": "CreateTransaction",
                "parameters": [
                    {
                        "description": "Transaction data to be created",
                        "name": "Transaction",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/TransactionCreatePayload"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/ResultResponse-Transaction"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/ErrorResponse"
                        }
                    }
                }
            }
        },
        "/transactions/{id}": {
            "get": {
                "description": "Get transaction by id",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "transasctions"
                ],
                "summary": "Get Transaction",
                "operationId": "GetTransaction",
                "parameters": [
                    {
                        "type": "string",
                        "description": "reference code of transaction",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/ResultResponse-Transaction"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/ErrorResponse"
                        }
                    }
                }
            }
        },
        "/users/me": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Get current user by validating authorization token",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "summary": "Get current user",
                "operationId": "GetMe",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/ResultResponse-User"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/ErrorResponse"
                        }
                    }
                }
            }
        },
        "/users/{id}": {
            "patch": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Update user by id",
                "consumes": [
                    "multipart/form-data"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "summary": "Update user",
                "operationId": "UpdateUser",
                "parameters": [
                    {
                        "type": "string",
                        "description": "User ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "file",
                        "description": "User profile image",
                        "name": "image",
                        "in": "formData",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/ResultResponse-User"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/ErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/ErrorResponse"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "Comment": {
            "type": "object",
            "properties": {
                "author": {
                    "$ref": "#/definitions/User"
                },
                "content": {
                    "type": "string"
                },
                "created_at": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "replies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/Reply"
                    }
                }
            }
        },
        "ErrorResponse": {
            "type": "object",
            "properties": {
                "error": {
                    "type": "string"
                },
                "status": {
                    "type": "string"
                },
                "status_code": {
                    "type": "integer"
                }
            }
        },
        "MessageResponse": {
            "type": "object",
            "properties": {
                "message": {
                    "type": "string"
                },
                "status": {
                    "type": "string"
                },
                "status_code": {
                    "type": "integer"
                }
            }
        },
        "PaginateResult-Post": {
            "type": "object",
            "properties": {
                "current_page": {
                    "type": "integer"
                },
                "data": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/Post"
                    }
                },
                "from": {
                    "type": "integer"
                },
                "last_page": {
                    "type": "integer"
                },
                "per_page": {
                    "type": "integer"
                },
                "to": {
                    "type": "integer"
                },
                "total": {
                    "type": "integer"
                }
            }
        },
        "PaginateResult-Project": {
            "type": "object",
            "properties": {
                "current_page": {
                    "type": "integer"
                },
                "data": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/Project"
                    }
                },
                "from": {
                    "type": "integer"
                },
                "last_page": {
                    "type": "integer"
                },
                "per_page": {
                    "type": "integer"
                },
                "to": {
                    "type": "integer"
                },
                "total": {
                    "type": "integer"
                }
            }
        },
        "PaginateResult-Transaction": {
            "type": "object",
            "properties": {
                "current_page": {
                    "type": "integer"
                },
                "data": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/Transaction"
                    }
                },
                "from": {
                    "type": "integer"
                },
                "last_page": {
                    "type": "integer"
                },
                "per_page": {
                    "type": "integer"
                },
                "to": {
                    "type": "integer"
                },
                "total": {
                    "type": "integer"
                }
            }
        },
        "Post": {
            "type": "object",
            "properties": {
                "author": {
                    "$ref": "#/definitions/User"
                },
                "comments": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/Comment"
                    }
                },
                "content": {
                    "type": "string"
                },
                "created_at": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "project": {
                    "$ref": "#/definitions/Project"
                },
                "title": {
                    "type": "string"
                }
            }
        },
        "Project": {
            "type": "object",
            "properties": {
                "category": {
                    "$ref": "#/definitions/ProjectCategory"
                },
                "created_at": {
                    "type": "string"
                },
                "current_funding": {
                    "type": "number"
                },
                "description": {
                    "type": "string"
                },
                "end_date": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "image": {
                    "type": "string"
                },
                "launch_date": {
                    "type": "string"
                },
                "location": {
                    "type": "string"
                },
                "monetary_unit": {
                    "type": "string"
                },
                "owner": {
                    "$ref": "#/definitions/User"
                },
                "rating": {
                    "type": "number"
                },
                "start_date": {
                    "type": "string"
                },
                "sub_category": {
                    "$ref": "#/definitions/ProjectSubCategory"
                },
                "sub_title": {
                    "type": "string"
                },
                "target_funding": {
                    "type": "number"
                },
                "title": {
                    "type": "string"
                }
            }
        },
        "ProjectCategory": {
            "type": "object",
            "properties": {
                "id": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "subcategories": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/ProjectSubCategory"
                    }
                }
            }
        },
        "ProjectSubCategory": {
            "type": "object",
            "properties": {
                "id": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                }
            }
        },
        "Reply": {
            "type": "object",
            "properties": {
                "author": {
                    "$ref": "#/definitions/User"
                },
                "content": {
                    "type": "string"
                },
                "created_at": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                }
            }
        },
        "ResultResponse-Comment": {
            "type": "object",
            "properties": {
                "result": {
                    "$ref": "#/definitions/Comment"
                },
                "status": {
                    "type": "string"
                },
                "status_code": {
                    "type": "integer"
                }
            }
        },
        "ResultResponse-PaginateResult-Post": {
            "type": "object",
            "properties": {
                "result": {
                    "$ref": "#/definitions/PaginateResult-Post"
                },
                "status": {
                    "type": "string"
                },
                "status_code": {
                    "type": "integer"
                }
            }
        },
        "ResultResponse-PaginateResult-Project": {
            "type": "object",
            "properties": {
                "result": {
                    "$ref": "#/definitions/PaginateResult-Project"
                },
                "status": {
                    "type": "string"
                },
                "status_code": {
                    "type": "integer"
                }
            }
        },
        "ResultResponse-PaginateResult-Transaction": {
            "type": "object",
            "properties": {
                "result": {
                    "$ref": "#/definitions/PaginateResult-Transaction"
                },
                "status": {
                    "type": "string"
                },
                "status_code": {
                    "type": "integer"
                }
            }
        },
        "ResultResponse-Post": {
            "type": "object",
            "properties": {
                "result": {
                    "$ref": "#/definitions/Post"
                },
                "status": {
                    "type": "string"
                },
                "status_code": {
                    "type": "integer"
                }
            }
        },
        "ResultResponse-Project": {
            "type": "object",
            "properties": {
                "result": {
                    "$ref": "#/definitions/Project"
                },
                "status": {
                    "type": "string"
                },
                "status_code": {
                    "type": "integer"
                }
            }
        },
        "ResultResponse-Reply": {
            "type": "object",
            "properties": {
                "result": {
                    "$ref": "#/definitions/Reply"
                },
                "status": {
                    "type": "string"
                },
                "status_code": {
                    "type": "integer"
                }
            }
        },
        "ResultResponse-Transaction": {
            "type": "object",
            "properties": {
                "result": {
                    "$ref": "#/definitions/Transaction"
                },
                "status": {
                    "type": "string"
                },
                "status_code": {
                    "type": "integer"
                }
            }
        },
        "ResultResponse-User": {
            "type": "object",
            "properties": {
                "result": {
                    "$ref": "#/definitions/User"
                },
                "status": {
                    "type": "string"
                },
                "status_code": {
                    "type": "integer"
                }
            }
        },
        "ResultResponse-UserAuthenticateResponse": {
            "type": "object",
            "properties": {
                "result": {
                    "$ref": "#/definitions/UserAuthenticateResponse"
                },
                "status": {
                    "type": "string"
                },
                "status_code": {
                    "type": "integer"
                }
            }
        },
        "ResultResponse-array_Project": {
            "type": "object",
            "properties": {
                "result": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/Project"
                    }
                },
                "status": {
                    "type": "string"
                },
                "status_code": {
                    "type": "integer"
                }
            }
        },
        "ResultResponse-array_ProjectCategory": {
            "type": "object",
            "properties": {
                "result": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/ProjectCategory"
                    }
                },
                "status": {
                    "type": "string"
                },
                "status_code": {
                    "type": "integer"
                }
            }
        },
        "ResultResponse-bool": {
            "type": "object",
            "properties": {
                "result": {
                    "type": "boolean"
                },
                "status": {
                    "type": "string"
                },
                "status_code": {
                    "type": "integer"
                }
            }
        },
        "ResultResponse-internal_http_handler_RenewAccessTokenResponse": {
            "type": "object",
            "properties": {
                "result": {
                    "$ref": "#/definitions/internal_http_handler.RenewAccessTokenResponse"
                },
                "status": {
                    "type": "string"
                },
                "status_code": {
                    "type": "integer"
                }
            }
        },
        "Transaction": {
            "type": "object",
            "properties": {
                "created_at": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "ref_code": {
                    "type": "string"
                },
                "updated_at": {
                    "type": "string"
                }
            }
        },
        "TransactionCreatePayload": {
            "type": "object",
            "required": [
                "ref_code"
            ],
            "properties": {
                "ref_code": {
                    "type": "string"
                }
            }
        },
        "User": {
            "type": "object",
            "properties": {
                "birthdate": {
                    "type": "string"
                },
                "created_at": {
                    "type": "string"
                },
                "display_name": {
                    "type": "string"
                },
                "email": {
                    "type": "string"
                },
                "full_name": {
                    "type": "string"
                },
                "gender": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "is_email_verified": {
                    "type": "boolean"
                },
                "metamask_account_id": {
                    "type": "string"
                },
                "profile_image": {
                    "type": "string"
                },
                "updated_at": {
                    "type": "string"
                }
            }
        },
        "UserAuthenticateResponse": {
            "type": "object",
            "properties": {
                "access_token": {
                    "type": "string"
                },
                "access_token_expired_at": {
                    "type": "string"
                },
                "refresh_token": {
                    "type": "string"
                },
                "refresh_token_expired_at": {
                    "type": "string"
                },
                "session_id": {
                    "type": "string"
                },
                "user": {
                    "$ref": "#/definitions/User"
                }
            }
        },
        "UserCreatePayload": {
            "type": "object",
            "required": [
                "birthdate",
                "email",
                "firstname",
                "gender",
                "lastname",
                "password",
                "password_confirmation"
            ],
            "properties": {
                "birthdate": {
                    "type": "string",
                    "example": "2002-04-16T00:00:00Z"
                },
                "email": {
                    "type": "string",
                    "example": "someemail@gmail.com"
                },
                "firstname": {
                    "type": "string",
                    "example": "John"
                },
                "gender": {
                    "type": "string",
                    "example": "m"
                },
                "lastname": {
                    "type": "string",
                    "example": "Doe"
                },
                "password": {
                    "type": "string",
                    "example": "@Password123"
                },
                "password_confirmation": {
                    "type": "string",
                    "example": "@Password123"
                }
            }
        },
        "UserLoginPayload": {
            "type": "object",
            "required": [
                "email",
                "password"
            ],
            "properties": {
                "email": {
                    "type": "string",
                    "example": "someemail@gmail.com"
                },
                "password": {
                    "type": "string",
                    "example": "@Password123"
                }
            }
        },
        "fund-o_api-server_internal_entity.CommentCreatePayload": {
            "type": "object",
            "required": [
                "content"
            ],
            "properties": {
                "content": {
                    "type": "string"
                }
            }
        },
        "fund-o_api-server_internal_entity.PostCreatePayload": {
            "type": "object",
            "required": [
                "description",
                "project_id",
                "title"
            ],
            "properties": {
                "content": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "project_id": {
                    "type": "string"
                },
                "title": {
                    "type": "string"
                }
            }
        },
        "fund-o_api-server_internal_entity.ProjectCreatePayload": {
            "type": "object"
        },
        "fund-o_api-server_internal_entity.ProjectRatingCreatePayload": {
            "type": "object",
            "required": [
                "rating"
            ],
            "properties": {
                "rating": {
                    "type": "number",
                    "maximum": 5,
                    "minimum": 0
                }
            }
        },
        "fund-o_api-server_internal_entity.ReplyCreatePayload": {
            "type": "object",
            "required": [
                "content"
            ],
            "properties": {
                "content": {
                    "type": "string"
                }
            }
        },
        "internal_http_handler.RenewAccessTokenPayload": {
            "type": "object",
            "required": [
                "refresh_token"
            ],
            "properties": {
                "refresh_token": {
                    "type": "string"
                }
            }
        },
        "internal_http_handler.RenewAccessTokenResponse": {
            "type": "object",
            "properties": {
                "access_token": {
                    "type": "string"
                },
                "access_token_expired_at": {
                    "type": "string"
                }
            }
        },
        "internal_http_handler.SendVerifyEmailPayload": {
            "type": "object",
            "required": [
                "email"
            ],
            "properties": {
                "email": {
                    "type": "string"
                }
            }
        }
    },
    "securityDefinitions": {
        "ApiKeyAuth": {
            "type": "apiKey",
            "name": "Authorization",
            "in": "header"
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "1.0",
        Host:             "",
        BasePath:         "",
        Schemes:          []string{"http", "https"},
        Title:            "FundO API",
        Description:      "This is a sample server.",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov0" title="0">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package datasource

import (
        "fund-o/api-server/internal/datasource/driver"

        "github.com/rs/zerolog/log"
        "gorm.io/gorm"
)

type DatasourceConfig struct {
        driver.SqlDBConfig
}

type Datasource interface {
        GetSqlDB() *gorm.DB
        Close() error
}

type datasource struct {
        sql driver.SQLContext
}

func NewDatasourceContext(config *DatasourceConfig) Datasource <span class="cov0" title="0">{
        sqlDBContext := driver.NewSQLContext(&amp;config.SqlDBConfig)

        err := sqlDBContext.Connect()
        if err != nil </span><span class="cov0" title="0">{
                log.Panic().Err(err).Msg("Failed to connect to SQL database")
        }</span>

        <span class="cov0" title="0">return &amp;datasource{
                sql: sqlDBContext,
        }</span>
}

func (ds *datasource) GetSqlDB() *gorm.DB <span class="cov0" title="0">{
        return ds.sql.DB()
}</span>

func (ds *datasource) Close() error <span class="cov0" title="0">{
        err := ds.sql.Disconnect()
        return err
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package driver

import (
        "errors"
        "fmt"
        "fund-o/api-server/internal/datasource/driver/seeds"
        "fund-o/api-server/internal/entity"
        "github.com/rs/zerolog"
        "github.com/rs/zerolog/log"
        "gorm.io/driver/postgres"
        "gorm.io/gorm"

        gormLogger "gorm.io/gorm/logger"
)

type SqlDBConfig struct {
        SQL_HOST     string `mapstructure:"SQL_HOST"`
        SQL_USERNAME string `mapstructure:"SQL_USERNAME"`
        SQL_PASSWORD string `mapstructure:"SQL_PASSWORD"`
        SQL_PORT     int    `mapstructure:"SQL_PORT"`
        SQL_DATABASE string `mapstructure:"SQL_DATABASE"`
}

type SQLContext interface {
        Connect() error
        Disconnect() error
        DB() *gorm.DB
}

type sqlContext struct {
        dsn    string
        db     *gorm.DB
        logger zerolog.Logger
}

func NewSQLContext(config *SqlDBConfig) SQLContext <span class="cov0" title="0">{
        dsn := fmt.Sprintf(
                "host=%s user=%s password=%s dbname=%s port=%d sslmode=disable TimeZone=Asia/Bangkok",
                config.SQL_HOST,
                config.SQL_USERNAME,
                config.SQL_PASSWORD,
                config.SQL_DATABASE,
                config.SQL_PORT,
        )

        logger := log.With().
                Str("context", "sql").
                Str("dsn", fmt.Sprintf(
                        "postgres://%s:%s@%s:%d/%s",
                        config.SQL_USERNAME,
                        "*****",
                        config.SQL_HOST,
                        config.SQL_PORT,
                        config.SQL_DATABASE,
                )).Logger()

        return &amp;sqlContext{dsn: dsn, logger: logger}
}</span>

func (sql *sqlContext) Connect() error <span class="cov0" title="0">{
        sql.logger.Info().Msg("Connecting to SQL database...")

        if sql.dsn == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to connect to SQL database: DSN is empty")
        }</span>

        <span class="cov0" title="0">db, err := gorm.Open(postgres.New(postgres.Config{
                DSN: sql.dsn,
        }), &amp;gorm.Config{
                Logger: gormLogger.Default.LogMode(gormLogger.Silent),
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">sql.logger.Info().Msg("Connecting to SQL database completed")

        sql.db = db

        if err := sql.autoMigrateUp(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (sql *sqlContext) Disconnect() error <span class="cov0" title="0">{
        sql.logger.Info().Msg("Disconnecting from SQL database...")

        if sql.db != nil </span><span class="cov0" title="0">{
                db, err := sql.db.DB()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">err = db.Close()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">sql.logger.Info().Msg("Disconnecting from SQL database completed")

        return nil</span>
}

func (sql *sqlContext) DB() *gorm.DB <span class="cov0" title="0">{
        return sql.db
}</span>

func (sql *sqlContext) autoMigrateUp() error <span class="cov0" title="0">{
        db := sql.db
        if err := db.AutoMigrate(
                &amp;entity.Transaction{},
                &amp;entity.User{},
                &amp;entity.Session{},
                &amp;entity.Project{},
                &amp;entity.ProjectCategory{},
                &amp;entity.ProjectSubCategory{},
                &amp;entity.ProjectRating{},
                &amp;entity.ProjectBacker{},
                &amp;entity.VerifyEmail{},
                &amp;entity.Post{},
                &amp;entity.Comment{},
                &amp;entity.Reply{},
                &amp;entity.Channel{},
                &amp;entity.Message{},
        ); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := db.AutoMigrate(&amp;entity.ProjectCategory{}); err == nil &amp;&amp; db.Migrator().HasTable(&amp;entity.ProjectCategory{}) </span><span class="cov0" title="0">{
                if err := db.First(&amp;entity.ProjectCategory{}).Error; errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        for _, category := range seeds.ProjectCategorySeed </span><span class="cov0" title="0">{
                                if result := db.Create(&amp;category); result.Error != nil </span><span class="cov0" title="0">{
                                        return result.Error
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package repository

import (
        "fund-o/api-server/internal/entity"
        "gorm.io/gorm"
)

type ChannelRepository interface {
        Create(channel *entity.Channel) (*entity.Channel, error)
        GetExistingChannel(userId string, memberId string) (*entity.Channel, error)
        GetByUserID(userId string) ([]entity.Channel, error)
}

type channelRepository struct {
        db *gorm.DB
}

func NewChannelRepository(db *gorm.DB) ChannelRepository <span class="cov0" title="0">{
        return &amp;channelRepository{db: db}
}</span>

func (r *channelRepository) Create(channel *entity.Channel) (*entity.Channel, error) <span class="cov0" title="0">{
        result := r.db.
                Preload("Members").
                Preload("Messages").
                Create(&amp;channel).
                First(&amp;channel)
        if result.Error != nil </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">return channel, nil</span>
}

func (r *channelRepository) GetExistingChannel(userId string, memberId string) (*entity.Channel, error) <span class="cov0" title="0">{
        var channel entity.Channel
        result := r.db.Raw(`
                SELECT c.* 
                FROM channels c
                JOIN channel_members cm1 ON c.id = cm1.channel_id AND cm1.user_id = ?
                JOIN channel_members cm2 ON c.id = cm2.channel_id AND cm2.user_id = ?
        `, userId, memberId).Scan(&amp;channel)
        if result.Error != nil </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">if err := r.db.Model(&amp;channel).Association("Members").Find(&amp;channel.Members); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := r.db.Preload("Author").Model(&amp;channel).Association("Messages").Find(&amp;channel.Messages); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;channel, nil</span>
}

func (r *channelRepository) GetByUserID(userId string) ([]entity.Channel, error) <span class="cov0" title="0">{
        var channels []entity.Channel
        result := r.db.
                Preload("Members").
                Preload("Messages").
                Preload("Messages.Author").
                Joins("JOIN channel_members ON channels.id = channel_members.channel_id").
                Where("channel_members.user_id = ?", userId).
                Find(&amp;channels)
        if result.Error != nil </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">return channels, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package repository

import (
        "fund-o/api-server/internal/entity"
        "fund-o/api-server/pkg/pagination"
        "github.com/google/uuid"
        "github.com/rs/zerolog"
        "github.com/rs/zerolog/log"
        "gorm.io/gorm"
)

type forumRepository struct {
        db     *gorm.DB
        logger zerolog.Logger
}

type ForumRepository interface {
        ListPosts(findOptions pagination.PaginateFindOptions) []entity.Post
        CountPost() int64
        CreatePost(forum *entity.Post) (*entity.Post, error)
        FindPostByID(id uuid.UUID) (*entity.Post, error)
        FindAllPostsByAuthorID(authorID uuid.UUID) ([]entity.Post, error)
        CreateComment(comment *entity.Comment) (*entity.Comment, error)
        CreateReply(reply *entity.Reply) (*entity.Reply, error)
}

func NewForumRepository(db *gorm.DB) ForumRepository <span class="cov0" title="0">{
        logger := log.With().Str("module", "forum_repository").Logger()
        return &amp;forumRepository{db, logger}
}</span>

func (repo *forumRepository) ListPosts(findOptions pagination.PaginateFindOptions) (posts []entity.Post) <span class="cov0" title="0">{
        result := repo.db.
                Limit(findOptions.Limit).
                Offset(findOptions.Skip).
                Preload("Author").
                Preload("Project").
                Preload("Project.Owner").
                Preload("Project.Category").
                Preload("Project.SubCategory").
                Preload("Comments").
                Preload("Comments.Replies").
                Find(&amp;posts)
        if result.Error != nil </span><span class="cov0" title="0">{
                repo.logger.Error().Err(result.Error).Msg("failed to list posts")
                return
        }</span>

        <span class="cov0" title="0">return posts</span>
}

func (repo *forumRepository) CountPost() int64 <span class="cov0" title="0">{
        var count int64
        if result := repo.db.Model(&amp;entity.Post{}).Count(&amp;count); result.Error != nil </span><span class="cov0" title="0">{
                repo.logger.Error().Err(result.Error).Msg("failed to count posts")
                return 0
        }</span>

        <span class="cov0" title="0">return count</span>
}

func (repo *forumRepository) CreatePost(forum *entity.Post) (*entity.Post, error) <span class="cov0" title="0">{
        result := repo.db.
                Preload("Author").
                Create(&amp;forum).
                First(&amp;forum)
        if result.Error != nil </span><span class="cov0" title="0">{
                repo.logger.Error().Err(result.Error).Msg("failed to create post")
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">return forum, nil</span>
}

func (repo *forumRepository) FindPostByID(id uuid.UUID) (*entity.Post, error) <span class="cov0" title="0">{
        var forum entity.Post
        result := repo.db.
                Preload("Author").
                Preload("Comments").
                Preload("Comments.Author").
                Preload("Comments.Replies").
                Preload("Comments.Replies.Author").
                Where("id = ?", id).
                First(&amp;forum)
        if result.Error != nil </span><span class="cov0" title="0">{
                repo.logger.Error().Err(result.Error).Msg("failed to find post by id: " + id.String())
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">return &amp;forum, nil</span>
}

func (repo *forumRepository) FindAllPostsByAuthorID(authorID uuid.UUID) ([]entity.Post, error) <span class="cov0" title="0">{
        var forums []entity.Post
        result := repo.db.
                Preload("Author").
                Where("author_id = ?", authorID).
                Find(&amp;forums)
        if result.Error != nil </span><span class="cov0" title="0">{
                repo.logger.Error().Err(result.Error).Msg("failed to list posts by author id: " + authorID.String())
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">return forums, nil</span>
}

func (repo *forumRepository) CreateComment(comment *entity.Comment) (*entity.Comment, error) <span class="cov0" title="0">{
        result := repo.db.
                Preload("Author").
                Create(&amp;comment).
                First(&amp;comment)
        if result.Error != nil </span><span class="cov0" title="0">{
                repo.logger.Error().Err(result.Error).Msg("failed to create comment")
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">return comment, nil</span>
}

func (repo *forumRepository) CreateReply(reply *entity.Reply) (*entity.Reply, error) <span class="cov0" title="0">{
        result := repo.db.
                Preload("Author").
                Create(&amp;reply).
                First(&amp;reply)
        if result.Error != nil </span><span class="cov0" title="0">{
                repo.logger.Error().Err(result.Error).Msg("failed to create reply")
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">return reply, nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package repository

import (
        "fund-o/api-server/internal/entity"
        "gorm.io/gorm"
)

type MessageRepository interface {
        Create(message *entity.Message) (*entity.Message, error)
}

type messageRepository struct {
        db *gorm.DB
}

func NewMessageRepository(db *gorm.DB) MessageRepository <span class="cov0" title="0">{
        return &amp;messageRepository{db: db}
}</span>

func (r *messageRepository) Create(message *entity.Message) (*entity.Message, error) <span class="cov0" title="0">{
        result := r.db.
                Preload("Author").
                Create(&amp;message).
                First(&amp;message)
        if result.Error != nil </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">return message, nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: internal/datasource/repository/transaction_repository.go

// Package mock_repository is a generated GoMock package.
package mock_repository

import (
        reflect "reflect"

        entity "fund-o/api-server/internal/entity"
        pagination "fund-o/api-server/pkg/pagination"
        gomock "github.com/golang/mock/gomock"
)

// MockTransactionRepository is a mock of TransactionRepository interface.
type MockTransactionRepository struct {
        ctrl     *gomock.Controller
        recorder *MockTransactionRepositoryMockRecorder
}

// MockTransactionRepositoryMockRecorder is the mock recorder for MockTransactionRepository.
type MockTransactionRepositoryMockRecorder struct {
        mock *MockTransactionRepository
}

// NewMockTransactionRepository creates a new mock instance.
func NewMockTransactionRepository(ctrl *gomock.Controller) *MockTransactionRepository <span class="cov5" title="2">{
        mock := &amp;MockTransactionRepository{ctrl: ctrl}
        mock.recorder = &amp;MockTransactionRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTransactionRepository) EXPECT() *MockTransactionRepositoryMockRecorder <span class="cov10" title="4">{
        return m.recorder
}</span>

// Count mocks base method.
func (m *MockTransactionRepository) Count() int64 <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Count")
        ret0, _ := ret[0].(int64)
        return ret0
}</span>

// Count indicates an expected call of Count.
func (mr *MockTransactionRepositoryMockRecorder) Count() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Count", reflect.TypeOf((*MockTransactionRepository)(nil).Count))
}</span>

// Create mocks base method.
func (m *MockTransactionRepository) Create(transaction *entity.Transaction) (*entity.Transaction, error) <span class="cov1" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Create", transaction)
        ret0, _ := ret[0].(*entity.Transaction)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Create indicates an expected call of Create.
func (mr *MockTransactionRepositoryMockRecorder) Create(transaction interface{}) *gomock.Call <span class="cov5" title="2">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockTransactionRepository)(nil).Create), transaction)
}</span>

// FindByRefCode mocks base method.
func (m *MockTransactionRepository) FindByRefCode(refCode string) (*entity.Transaction, error) <span class="cov5" title="2">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindByRefCode", refCode)
        ret0, _ := ret[0].(*entity.Transaction)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// FindByRefCode indicates an expected call of FindByRefCode.
func (mr *MockTransactionRepositoryMockRecorder) FindByRefCode(refCode interface{}) *gomock.Call <span class="cov5" title="2">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByRefCode", reflect.TypeOf((*MockTransactionRepository)(nil).FindByRefCode), refCode)
}</span>

// List mocks base method.
func (m *MockTransactionRepository) List(findOptions pagination.PaginateFindOptions) []entity.Transaction <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "List", findOptions)
        ret0, _ := ret[0].([]entity.Transaction)
        return ret0
}</span>

// List indicates an expected call of List.
func (mr *MockTransactionRepositoryMockRecorder) List(findOptions interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "List", reflect.TypeOf((*MockTransactionRepository)(nil).List), findOptions)
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package repository

import (
        "fund-o/api-server/internal/entity"
        "github.com/rs/zerolog"

        "github.com/rs/zerolog/log"
        "gorm.io/gorm"
)

type ProjectCategoryRepository interface {
        FindAll() ([]entity.ProjectCategory, error)
}

type projectCategoryRepository struct {
        db     *gorm.DB
        logger zerolog.Logger
}

func NewProjectCategoryRepository(db *gorm.DB) ProjectCategoryRepository <span class="cov0" title="0">{
        logger := log.With().Str("module", "project_category_repository").Logger()
        return &amp;projectCategoryRepository{db, logger}
}</span>

func (repo *projectCategoryRepository) FindAll() ([]entity.ProjectCategory, error) <span class="cov0" title="0">{
        var categories []entity.ProjectCategory
        if result := repo.db.Preload("SubCategories").Find(&amp;categories); result.Error != nil </span><span class="cov0" title="0">{
                repo.logger.Error().Err(result.Error).Msg("failed to list project categories")
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">return categories, nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package repository

import (
        "fmt"
        "fund-o/api-server/internal/entity"
        "fund-o/api-server/pkg/pagination"
        "github.com/rs/zerolog"
        "strings"

        "github.com/google/uuid"

        "github.com/rs/zerolog/log"
        "gorm.io/gorm"
)

type ProjectRepository interface {
        FindAll(paginateOptions pagination.PaginateFindOptions, findOptions entity.ProjectListOptions) []entity.Project
        Count() int64
        Create(project *entity.Project) (*entity.Project, error)
        FindByID(projectID uuid.UUID) (*entity.Project, error)
        FindAllByOwnerID(ownerID uuid.UUID) ([]entity.Project, error)
        FindRecommendation(count int) ([]entity.Project, error)
        CreateProjectRating(rating *entity.ProjectRating) (*entity.ProjectRating, error)
        FindProjectRating(userID uuid.UUID, projectID uuid.UUID) (*entity.ProjectRating, error)
        GetProjectBacker(userID, projectID uuid.UUID) (entity.ProjectBacker, error)
        CreateProjectBacker(backer *entity.ProjectBacker) (*entity.ProjectBacker, error)
        UpdateProjectBacker(backer *entity.ProjectBacker) (*entity.ProjectBacker, error)
        FindBackProjectsByUserID(userID string) ([]entity.ProjectFunding, error)
}

type projectRepository struct {
        db     *gorm.DB
        logger zerolog.Logger
}

func NewProjectRepository(db *gorm.DB) ProjectRepository <span class="cov0" title="0">{
        logger := log.With().Str("module", "project_repository").Logger()
        return &amp;projectRepository{db, logger}
}</span>

func (repo *projectRepository) FindAll(paginateOptions pagination.PaginateFindOptions, findOptions entity.ProjectListOptions) (projects []entity.Project) <span class="cov0" title="0">{
        query := repo.db.
                Limit(paginateOptions.Limit).
                Offset(paginateOptions.Skip).
                Where("LOWER(title) LIKE ?", "%"+strings.ToLower(findOptions.Query)+"%").
                Preload("Category").
                Preload("SubCategory").
                Preload("Owner").
                Preload("Ratings")

        if findOptions.CategoryID != uuid.Nil </span><span class="cov0" title="0">{
                query = query.Where("category_id = ?", findOptions.CategoryID)
        }</span>

        <span class="cov0" title="0">if findOptions.SubCategoryID != uuid.Nil </span><span class="cov0" title="0">{
                query = query.Where("sub_category_id = ?", findOptions.SubCategoryID)
        }</span>

        <span class="cov0" title="0">result := query.Find(&amp;projects)
        if result.Error != nil </span><span class="cov0" title="0">{
                repo.logger.Error().Err(result.Error).Msg("failed to list projects")
                return
        }</span>

        <span class="cov0" title="0">return projects</span>
}

func (repo *projectRepository) Count() int64 <span class="cov0" title="0">{
        var count int64
        if result := repo.db.Model(&amp;entity.Project{}).Count(&amp;count); result.Error != nil </span><span class="cov0" title="0">{
                repo.logger.Error().Err(result.Error).Msg("failed to count projects")
                return 0
        }</span>

        <span class="cov0" title="0">return count</span>
}

func (repo *projectRepository) Create(project *entity.Project) (*entity.Project, error) <span class="cov0" title="0">{
        result := repo.db.
                Preload("Category").
                Preload("SubCategory").
                Preload("Ratings").
                Create(&amp;project).
                First(&amp;project)
        if result.Error != nil </span><span class="cov0" title="0">{
                repo.logger.Error().Err(result.Error).Msg("failed to create project")
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">return project, nil</span>
}

func (repo *projectRepository) FindByID(projectID uuid.UUID) (*entity.Project, error) <span class="cov0" title="0">{
        var project entity.Project
        result := repo.db.
                Preload("Owner").
                Preload("Category").
                Preload("SubCategory").
                Preload("Ratings").
                Where("id = ?", projectID).
                First(&amp;project)
        if result.Error != nil </span><span class="cov0" title="0">{
                repo.logger.Error().Err(result.Error).Msg("failed to find project by id")
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">return &amp;project, nil</span>
}

func (repo *projectRepository) FindAllByOwnerID(ownerID uuid.UUID) ([]entity.Project, error) <span class="cov0" title="0">{
        var projects []entity.Project
        result := repo.db.
                Preload("Owner").
                Preload("Category").
                Preload("SubCategory").
                Preload("Ratings").
                Where("owner_id = ?", ownerID).
                Find(&amp;projects)
        if result.Error != nil </span><span class="cov0" title="0">{
                repo.logger.Error().Err(result.Error).Msg("failed to list projects")
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">for _, project := range projects </span><span class="cov0" title="0">{
                fmt.Println(ownerID)
                fmt.Println("project owner: ", project.OwnerID)
        }</span>

        <span class="cov0" title="0">return projects, nil</span>
}

func (repo *projectRepository) FindRecommendation(count int) ([]entity.Project, error) <span class="cov0" title="0">{
        var projects []entity.Project
        result := repo.db.Table("projects").
                Preload("Owner").
                Preload("Category").
                Preload("SubCategory").
                Preload("Ratings").
                Select("projects.*, AVG(project_ratings.rating) AS avg_rating").
                Joins("LEFT JOIN project_ratings ON projects.id = project_ratings.project_id").
                Group("projects.id").
                Having("AVG(project_ratings.rating) &gt; 0").
                Order("avg_rating DESC").
                Limit(count).
                Find(&amp;projects)
        if result.Error != nil </span><span class="cov0" title="0">{
                repo.logger.Error().Err(result.Error).Msg("failed to find recommendation")
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">return projects, nil</span>
}

func (repo *projectRepository) CreateProjectRating(rating *entity.ProjectRating) (*entity.ProjectRating, error) <span class="cov0" title="0">{
        result := repo.db.
                Create(&amp;rating).
                First(&amp;rating)
        if result.Error != nil </span><span class="cov0" title="0">{
                repo.logger.Error().Err(result.Error).Msg("failed to create project rating")
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">return rating, nil</span>
}

func (repo *projectRepository) FindProjectRating(userID uuid.UUID, projectID uuid.UUID) (*entity.ProjectRating, error) <span class="cov0" title="0">{
        var rating entity.ProjectRating
        result := repo.db.
                Where("project_id = ? AND user_id = ?", projectID, userID).
                Find(&amp;rating)
        if result.Error != nil </span><span class="cov0" title="0">{
                repo.logger.Error().Err(result.Error).Msg("failed to find project rating")
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">return &amp;rating, nil</span>
}

func (repo *projectRepository) GetProjectBacker(userID, projectID uuid.UUID) (entity.ProjectBacker, error) <span class="cov0" title="0">{
        var backer entity.ProjectBacker
        result := repo.db.
                Where("project_id = ? AND user_id = ?", projectID, userID).
                First(&amp;backer)
        if result.Error != nil </span><span class="cov0" title="0">{
                repo.logger.Error().Err(result.Error).Msg("failed to find project backer")
                return backer, result.Error
        }</span>

        <span class="cov0" title="0">return backer, nil</span>
}

func (repo *projectRepository) CreateProjectBacker(backer *entity.ProjectBacker) (*entity.ProjectBacker, error) <span class="cov0" title="0">{
        result := repo.db.
                Create(&amp;backer).
                First(&amp;backer)
        if result.Error != nil </span><span class="cov0" title="0">{
                repo.logger.Error().Err(result.Error).Msg("failed to create project backer")
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">return backer, nil</span>
}

func (repo *projectRepository) UpdateProjectBacker(backer *entity.ProjectBacker) (*entity.ProjectBacker, error) <span class="cov0" title="0">{
        result := repo.db.
                Save(&amp;backer).
                First(&amp;backer)
        if result.Error != nil </span><span class="cov0" title="0">{
                repo.logger.Error().Err(result.Error).Msg("failed to update project backer")
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">return backer, nil</span>
}

func (repo *projectRepository) FindBackProjectsByUserID(userID string) ([]entity.ProjectFunding, error) <span class="cov0" title="0">{
        var projectFundings []entity.ProjectFunding

        // Execute raw SQL query to calculate the sum of the amount funded for each project by the user
        result := repo.db.Raw(`
        SELECT projects.id as project_id, SUM(project_backers.amount) as total_funds
        FROM projects
        JOIN project_backers ON projects.id = project_backers.project_id
        WHERE project_backers.user_id = ?
        GROUP BY projects.id
    `, userID).Scan(&amp;projectFundings)
        if result.Error != nil </span><span class="cov0" title="0">{
                repo.logger.Error().Err(result.Error).Msg("failed to find back projects by user id")
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">return projectFundings, nil</span>
        //var projects []entity.ListBackedProjectResponse
        //
        //result := repo.db.
        //        Table("projects").
        //        Preload("Owner").
        //        Preload("Category").
        //        Preload("SubCategory").
        //        Preload("Ratings").
        //        Joins("JOIN project_backers ON projects.id = project_backers.project_id").
        //        Where("project_backers.user_id = ?", userID).
        //        Find(&amp;projects)
        //if result.Error != nil {
        //        repo.logger.Error().Err(result.Error).Msg("failed to find back projects by user id")
        //        return nil, result.Error
        //}
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package repository

import (
        "fund-o/api-server/internal/entity"
        "github.com/rs/zerolog"

        "github.com/google/uuid"

        "github.com/rs/zerolog/log"
        "gorm.io/gorm"
)

type SessionRepository interface {
        Create(session *entity.Session) (*entity.Session, error)
        FindByID(id uuid.UUID) (*entity.Session, error)
}

type sessionRepository struct {
        db     *gorm.DB
        logger zerolog.Logger
}

func NewSessionRepository(db *gorm.DB) SessionRepository <span class="cov0" title="0">{
        logger := log.With().Str("module", "session_repository").Logger()
        return &amp;sessionRepository{db, logger}
}</span>

func (repo *sessionRepository) Create(session *entity.Session) (*entity.Session, error) <span class="cov0" title="0">{
        if result := repo.db.Create(&amp;session); result.Error != nil </span><span class="cov0" title="0">{
                repo.logger.Error().Err(result.Error).Msg("failed to create session")
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">return session, nil</span>
}

func (repo *sessionRepository) FindByID(id uuid.UUID) (*entity.Session, error) <span class="cov0" title="0">{
        var session entity.Session
        if result := repo.db.Where("id = ?", id).First(&amp;session); result.Error != nil </span><span class="cov0" title="0">{
                repo.logger.Error().Err(result.Error).Msg("failed to find session by id: " + id.String())
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">return &amp;session, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package repository

import (
        "fund-o/api-server/internal/entity"
        "fund-o/api-server/pkg/pagination"
        "github.com/rs/zerolog"

        "gorm.io/gorm"

        "github.com/rs/zerolog/log"
)

type TransactionRepository interface {
        Create(transaction *entity.Transaction) (*entity.Transaction, error)
        FindByRefCode(refCode string) (*entity.Transaction, error)
        List(findOptions pagination.PaginateFindOptions) []entity.Transaction
        Count() int64
}

type transactionRepository struct {
        db     *gorm.DB
        logger zerolog.Logger
}

func NewTransactionRepository(db *gorm.DB) TransactionRepository <span class="cov0" title="0">{
        logger := log.With().Str("module", "transaction_repository").Logger()
        return &amp;transactionRepository{db, logger}
}</span>

func (repo *transactionRepository) Create(transaction *entity.Transaction) (*entity.Transaction, error) <span class="cov0" title="0">{
        if result := repo.db.Create(&amp;transaction); result.Error != nil </span><span class="cov0" title="0">{
                repo.logger.Error().Err(result.Error).Msg("failed to create transaction")
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">return transaction, nil</span>
}

func (repo *transactionRepository) FindByRefCode(refCode string) (*entity.Transaction, error) <span class="cov0" title="0">{
        var transaction entity.Transaction
        if result := repo.db.Where("ref_code = ?", refCode).First(&amp;transaction); result.Error != nil </span><span class="cov0" title="0">{
                repo.logger.Error().Err(result.Error).Msg("failed to find transaction by reference code: " + refCode)
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">return &amp;transaction, nil</span>
}

func (repo *transactionRepository) List(findOptions pagination.PaginateFindOptions) (transactions []entity.Transaction) <span class="cov0" title="0">{
        if result := repo.db.Limit(findOptions.Limit).Offset(findOptions.Skip).Find(&amp;transactions); result.Error != nil </span><span class="cov0" title="0">{
                repo.logger.Error().Err(result.Error).Msg("failed to list transactions")
                return
        }</span>

        <span class="cov0" title="0">return transactions</span>
}

func (repo *transactionRepository) Count() int64 <span class="cov0" title="0">{
        var count int64
        if result := repo.db.Model(&amp;entity.Transaction{}).Count(&amp;count); result.Error != nil </span><span class="cov0" title="0">{
                repo.logger.Error().Err(result.Error).Msg("failed to count transactions")
                return 0
        }</span>

        <span class="cov0" title="0">return count</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package repository

import (
        "fund-o/api-server/internal/entity"
        "github.com/google/uuid"
        "github.com/rs/zerolog"
        "github.com/rs/zerolog/log"
        "gorm.io/gorm"
)

type UserRepository interface {
        Create(user *entity.User) (*entity.User, error)
        FindByEmail(email string) (*entity.User, error)
        FindById(id uuid.UUID) (*entity.User, error)
        UpdateByID(id uuid.UUID, user *entity.User) (*entity.User, error)
}

type userRepository struct {
        db     *gorm.DB
        logger zerolog.Logger
}

func NewUserRepository(db *gorm.DB) UserRepository <span class="cov0" title="0">{
        logger := log.With().Str("module", "user_repository").Logger()
        return &amp;userRepository{db, logger}
}</span>

func (repo *userRepository) Create(user *entity.User) (*entity.User, error) <span class="cov0" title="0">{
        if result := repo.db.Create(&amp;user); result.Error != nil </span><span class="cov0" title="0">{
                repo.logger.Error().Err(result.Error).Msg("failed to create user")
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

func (repo *userRepository) FindByEmail(email string) (*entity.User, error) <span class="cov0" title="0">{
        var user entity.User
        if result := repo.db.Where("email = ?", email).First(&amp;user); result.Error != nil </span><span class="cov0" title="0">{
                repo.logger.Error().Err(result.Error).Msg("failed to find user by email: " + email)
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">return &amp;user, nil</span>
}

func (repo *userRepository) FindById(id uuid.UUID) (*entity.User, error) <span class="cov0" title="0">{
        var user entity.User
        if result := repo.db.First(&amp;user, id); result.Error != nil </span><span class="cov0" title="0">{
                repo.logger.Error().Err(result.Error).Msg("failed to find user by id: " + id.String())
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">return &amp;user, nil</span>
}

func (repo *userRepository) UpdateByID(id uuid.UUID, user *entity.User) (*entity.User, error) <span class="cov0" title="0">{
        if result := repo.db.Model(&amp;entity.User{}).Where("id = ?", id).Updates(&amp;user).First(&amp;user); result.Error != nil </span><span class="cov0" title="0">{
                repo.logger.Error().Err(result.Error).Msg("failed to update user by id: " + id.String())
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package repository

import (
        "fund-o/api-server/internal/entity"
        "github.com/rs/zerolog"
        "github.com/rs/zerolog/log"
        "gorm.io/gorm"
)

type VerifyEmailRepository interface {
        Create(verifyEmail *entity.VerifyEmail) (*entity.VerifyEmail, error)
        FindByID(id string) (*entity.VerifyEmail, error)
        UpdateByID(id string, verifyEmail *entity.VerifyEmail) (*entity.VerifyEmail, error)
}

type verifyEmailRepository struct {
        db     *gorm.DB
        logger zerolog.Logger
}

func NewVerifyEmailRepository(db *gorm.DB) VerifyEmailRepository <span class="cov0" title="0">{
        logger := log.With().Str("module", "verify_email_repository").Logger()
        return &amp;verifyEmailRepository{db, logger}
}</span>

func (repo *verifyEmailRepository) Create(verifyEmail *entity.VerifyEmail) (*entity.VerifyEmail, error) <span class="cov0" title="0">{
        if result := repo.db.Create(&amp;verifyEmail); result.Error != nil </span><span class="cov0" title="0">{
                repo.logger.Error().Err(result.Error).Msg("failed to create verify email: " + verifyEmail.Email)
                return nil, result.Error
        }</span>
        <span class="cov0" title="0">return verifyEmail, nil</span>
}

func (repo *verifyEmailRepository) FindByID(id string) (*entity.VerifyEmail, error) <span class="cov0" title="0">{
        var ve entity.VerifyEmail
        if result := repo.db.Where("id = ?", id).First(&amp;ve); result.Error != nil </span><span class="cov0" title="0">{
                repo.logger.Error().Err(result.Error).Msg("failed to find verify email by id: " + id)
                return nil, result.Error
        }</span>
        <span class="cov0" title="0">return &amp;ve, nil</span>
}

func (repo *verifyEmailRepository) UpdateByID(id string, verifyEmail *entity.VerifyEmail) (*entity.VerifyEmail, error) <span class="cov0" title="0">{
        if result := repo.db.Model(&amp;entity.VerifyEmail{}).Where("id = ?", id).Updates(verifyEmail); result.Error != nil </span><span class="cov0" title="0">{
                repo.logger.Error().Err(result.Error).Msg("failed to update verify email by id: " + id)
                return nil, result.Error
        }</span>
        <span class="cov0" title="0">return verifyEmail, nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package entity

type Channel struct {
        Base
        Name     string    `gorm:"type:varchar(255);not null"`
        Messages []Message `gorm:"foreignKey:ChannelID"`
        Members  []User    `gorm:"many2many:channel_members;"`
}

type ChannelDto struct {
        ID       string       `json:"id"`
        Name     string       `json:"name"`
        Messages []MessageDto `json:"messages"`
        Members  []UserDto    `json:"members"`
}

// Secondary types

type GetOwnChannelsResponse struct {
        Receiver    UserDto     `json:"receiver"`
        LastMessage *MessageDto `json:"last_message"`
}

type ChannelCreatePayload struct {
        Name    string `json:"name"`
        Members []string
}

// Parse functions

func (c *Channel) ToChannelDto() *ChannelDto <span class="cov0" title="0">{
        var messages []MessageDto
        for _, m := range c.Messages </span><span class="cov0" title="0">{
                messages = append(messages, *m.ToMessageDto())
        }</span>

        <span class="cov0" title="0">var members []UserDto
        for _, u := range c.Members </span><span class="cov0" title="0">{
                members = append(members, *u.ToUserDto())
        }</span>

        <span class="cov0" title="0">return &amp;ChannelDto{
                ID:       c.ID.String(),
                Name:     c.Name,
                Messages: messages,
                Members:  members,
        }</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package entity

import (
        "database/sql/driver"
        "encoding/json"
)

type DecimalArray []float64

func (a *DecimalArray) Value() (driver.Value, error) <span class="cov0" title="0">{
        return json.Marshal(a)
}</span>

func (a *DecimalArray) Scan(value interface{}) error <span class="cov0" title="0">{
        bytes, ok := value.([]byte)
        if !ok </span><span class="cov0" title="0">{
                return nil // or return an error, depending on your requirements
        }</span>

        <span class="cov0" title="0">var array []float64
        if err := json.Unmarshal(bytes, &amp;array); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">*a = array
        return nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package entity

import (
        "github.com/google/uuid"
        "time"
)

type Post struct {
        Base
        Title       string    `gorm:"type:varchar(255);not null"`
        Description string    `gorm:"type:varchar(255);not null"`
        Content     string    `gorm:"not null"`
        AuthorID    uuid.UUID `gorm:"not null"`
        Author      User      `gorm:"foreignKey:AuthorID"`
        ProjectID   uuid.UUID `gorm:"not null"`
        Project     Project   `gorm:"foreignKey:ProjectID"`
        Comments    []Comment
}

type PostDto struct {
        ID          string       `json:"id"`
        Title       string       `json:"title"`
        Description string       `json:"description"`
        Content     string       `json:"content"`
        Author      *UserDto     `json:"author"`
        Project     *ProjectDto  `json:"project"`
        Comments    []CommentDto `json:"comments"`
        CreatedAt   string       `json:"created_at"`
} // @name Post

type Comment struct {
        Base
        Content  string `gorm:"type:varchar(255);not null"`
        AuthorID uuid.UUID
        Author   User `gorm:"foreignKey:AuthorID"`
        PostID   uuid.UUID
        Replies  []Reply
}

type CommentDto struct {
        ID        string     `json:"id"`
        Content   string     `json:"content"`
        Author    *UserDto   `json:"author"`
        Replies   []ReplyDto `json:"replies"`
        CreatedAt string     `json:"created_at"`
} // @name Comment

type Reply struct {
        Base
        Content   string `gorm:"type:varchar(255);not null"`
        AuthorID  uuid.UUID
        Author    User `gorm:"foreignKey:AuthorID"`
        CommentID uuid.UUID
}

type ReplyDto struct {
        ID        string   `json:"id"`
        Content   string   `json:"content"`
        Author    *UserDto `json:"author"`
        CreatedAt string   `json:"created_at"`
} // @name Reply

// Secondary types

type PostCreatePayload struct {
        Title       string `json:"title" binding:"required"`
        Description string `json:"description" binding:"required"`
        Content     string `json:"content"`
        ProjectID   string `json:"project_id" binding:"required"`
        AuthorID    string `swaggerignore:"true"`
}

type CommentCreatePayload struct {
        Content  string `json:"content" binding:"required"`
        AuthorID string `swaggerignore:"true"`
}

type ReplyCreatePayload struct {
        Content  string `json:"content" binding:"required"`
        AuthorID string `swaggerignore:"true"`
}

// Parse functions

func (f *Post) ToPostDto() *PostDto <span class="cov10" title="47">{
        comments := make([]CommentDto, len(f.Comments))
        for i, comment := range f.Comments </span><span class="cov0" title="0">{
                comments[i] = *comment.ToCommentDto()
        }</span>

        <span class="cov10" title="47">return &amp;PostDto{
                ID:          f.ID.String(),
                Title:       f.Title,
                Description: f.Description,
                Content:     f.Content,
                Author:      f.Author.ToUserDto(),
                Project:     f.Project.ToProjectDto(),
                Comments:    comments,
                CreatedAt:   f.CreatedAt.Format(time.RFC3339),
        }</span>
}

func (c *Comment) ToCommentDto() *CommentDto <span class="cov0" title="0">{
        replies := make([]ReplyDto, len(c.Replies))
        for i, reply := range c.Replies </span><span class="cov0" title="0">{
                replies[i] = *reply.ToReplyDto()
        }</span>

        <span class="cov0" title="0">return &amp;CommentDto{
                ID:        c.ID.String(),
                Content:   c.Content,
                Author:    c.Author.ToUserDto(),
                Replies:   replies,
                CreatedAt: c.CreatedAt.Format(time.RFC3339),
        }</span>
}

func (r *Reply) ToReplyDto() *ReplyDto <span class="cov0" title="0">{
        return &amp;ReplyDto{
                ID:        r.ID.String(),
                Content:   r.Content,
                Author:    r.Author.ToUserDto(),
                CreatedAt: r.CreatedAt.Format(time.RFC3339),
        }
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package entity

import (
        "github.com/google/uuid"
        "mime/multipart"
        "time"
)

type Message struct {
        Base
        Text       *string `gorm:"varchar(255)"`
        Attachment *string `gorm:"varchar(255)"`
        ChannelID  uuid.UUID
        AuthorID   uuid.UUID
        Author     User `gorm:"foreignKey:AuthorID"`
}

type MessageDto struct {
        Text       *string  `json:"text"`
        Attachment *string  `json:"attachment"`
        Author     *UserDto `json:"author"`
        CreatedAt  string   `json:"created_at"`
}

// Secondary types

type MessageCreatePayload struct {
        Text       *string               `form:"text"`
        Attachment *multipart.FileHeader `form:"attachment"`
        ChannelID  uuid.UUID             `form:"-"`
        AuthorID   uuid.UUID             `form:"-"`
}

// Parse functions

func (m *Message) ToMessageDto() *MessageDto <span class="cov0" title="0">{
        return &amp;MessageDto{
                Text:       m.Text,
                Attachment: m.Attachment,
                Author:     m.Author.ToUserDto(),
                CreatedAt:  m.CreatedAt.Format(time.RFC3339),
        }
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package entity

import (
        "fund-o/api-server/pkg/pagination"
        "mime/multipart"
        "time"

        "github.com/google/uuid"
        "github.com/shopspring/decimal"
)

type OldProject struct {
        Base
        Title          string `gorm:"type:varchar(255);not null"`
        SubTitle       string `gorm:"not null"`
        Description    string
        CategoryID     uuid.UUID       `gorm:"not null"`
        Category       ProjectCategory `gorm:"foreignKey:CategoryID"`
        SubCategoryID  uuid.UUID
        SubCategory    ProjectSubCategory `gorm:"foreignKey:SubCategoryID"`
        Location       string             `gorm:"not null"`
        Image          string
        Ratings        []ProjectRating
        TargetFunding  decimal.Decimal `gorm:"type:decimal(32,16)"`
        CurrentFunding decimal.Decimal `gorm:"type:decimal(32,16)"`
        MonetaryUnit   string          `gorm:"default:'THB'"`
        StartDate      time.Time       `gorm:"not null;default:CURRENT_TIMESTAMP"`
        EndDate        time.Time       `gorm:"not null"`
        LaunchDate     time.Time       `gorm:"default:null"`
        OwnerID        uuid.UUID       `gorm:"not null"`
        Owner          User            `gorm:"foreignKey:OwnerID"`
}

type Project struct {
        Base
        ProjectContractID string    `gorm:"type:varchar(255);not null"`
        Title             string    `gorm:"type:varchar(255);not null"`
        SubTitle          string    `gorm:"not null"`
        CategoryID        uuid.UUID `gorm:"not null"`
        Description       string
        Category          ProjectCategory `gorm:"foreignKey:CategoryID"`
        SubCategoryID     uuid.UUID
        SubCategory       ProjectSubCategory `gorm:"foreignKey:SubCategoryID"`
        Location          string             `gorm:"not null"`
        Image             string
        Ratings           []ProjectRating
        Backers           []ProjectBacker
        StartDate         time.Time `gorm:"not null;default:CURRENT_TIMESTAMP"`
        EndDate           time.Time `gorm:"not null"`
        OwnerID           uuid.UUID `gorm:"not null"`
        Owner             User      `gorm:"foreignKey:OwnerID"`
}

type ProjectDto struct {
        ID                string                 `json:"id"`
        ProjectContractID string                 `json:"project_contract_id"`
        Title             string                 `json:"title"`
        SubTitle          string                 `json:"sub_title"`
        Description       string                 `json:"description"`
        Category          *ProjectCategoryDto    `json:"category"`
        SubCategory       *ProjectSubCategoryDto `json:"sub_category"`
        Location          string                 `json:"location"`
        Image             string                 `json:"image"`
        Rating            float32                `json:"rating"`
        StartDate         string                 `json:"start_date"`
        EndDate           string                 `json:"end_date"`
        Owner             *UserDto               `json:"owner"`
        CreatedAt         string                 `json:"created_at"`
} // @name Project

type ProjectRating struct {
        Base
        Rating    float32 `gorm:"not null"`
        ProjectID uuid.UUID
        UserID    uuid.UUID
} // @name ProjectRating

type ProjectBacker struct {
        Base
        ProjectID uuid.UUID
        UserID    uuid.UUID
        Amount    decimal.Decimal `gorm:"type:decimal(32,16)"`
}

// Secondary types

type ProjectListParams struct {
        pagination.PaginateOptions
        Query         string `form:"q"`
        CategoryID    string `form:"category"`
        SubCategoryID string `form:"sub_category"`
}

type ProjectListOptions struct {
        Query         string
        CategoryID    uuid.UUID
        SubCategoryID uuid.UUID
}

type ProjectCreatePayload struct {
        ProjectContractID string                `form:"project_contract_id" binding:"required"`
        Title             string                `form:"title" binding:"required"`
        SubTitle          string                `form:"sub_title" binding:"required"`
        Description       string                `form:"description"`
        CategoryID        string                `form:"category_id" binding:"required"`
        SubCategoryID     string                `form:"sub_category_id" binding:"required"`
        Location          string                `form:"location" binding:"required"`
        Image             *multipart.FileHeader `form:"image" binding:"required"`
        EndDate           string                `form:"end_date" binding:"required"`
        OwnerID           string                `swaggerignore:"true"`
}

type ProjectRatingCreatePayload struct {
        Rating    float32 `json:"rating" binding:"required,gte=0,lte=5"`
        ProjectID string  `json:"project_id" binding:"required" swaggerignore:"true"`
        UserID    string  `swaggerignore:"true"`
}

type ProjectBackerCreatePayload struct {
        ProjectID string  `json:"project_id" binding:"required"`
        Amount    float64 `json:"amount" binding:"required"`
}

type ListBackedProjectResponse struct {
        Project    ProjectDto      `json:"project"`
        FundAmount decimal.Decimal `json:"fund_amount"`
}

type ProjectFunding struct {
        ProjectID  uuid.UUID
        TotalFunds decimal.Decimal
}

// Parse functions

func (p *Project) ToProjectDto() *ProjectDto <span class="cov10" title="47">{
        rating := float32(0)

        if len(p.Ratings) &gt; 0 </span><span class="cov0" title="0">{
                totalRating := float32(0)
                for _, r := range p.Ratings </span><span class="cov0" title="0">{
                        totalRating += r.Rating
                }</span>
                <span class="cov0" title="0">rating = totalRating / float32(len(p.Ratings))</span>
        }

        <span class="cov10" title="47">return &amp;ProjectDto{
                ID:                p.ID.String(),
                ProjectContractID: p.ProjectContractID,
                Title:             p.Title,
                SubTitle:          p.SubTitle,
                Category:          p.Category.ToProjectCategoryDto(),
                SubCategory:       p.SubCategory.ToProjectSubCategoryDto(),
                Location:          p.Location,
                Rating:            rating,
                Image:             p.Image,
                Description:       p.Description,
                StartDate:         p.StartDate.Format(time.RFC3339),
                EndDate:           p.EndDate.Format(time.RFC3339),
                Owner:             p.Owner.ToUserDto(),
                CreatedAt:         p.CreatedAt.Format(time.RFC3339),
        }</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package entity

import "github.com/google/uuid"

type Category int

type ProjectCategory struct {
        Base
        Name          string               `gorm:"type:varchar(255);not null"`
        SubCategories []ProjectSubCategory `gorm:"foreignKey:CategoryID"`
}

type ProjectSubCategory struct {
        Base
        Name       string `gorm:"type:varchar(255);not null"`
        CategoryID uuid.UUID
}

type ProjectCategoryDto struct {
        ID            string                  `json:"id"`
        Name          string                  `json:"name"`
        SubCategories []ProjectSubCategoryDto `json:"subcategories"`
} // @name ProjectCategory

type ProjectSubCategoryDto struct {
        ID   string `json:"id"`
        Name string `json:"name"`
} // @name ProjectSubCategory

// Parse functions

func (p *ProjectCategory) ToProjectCategoryDto() *ProjectCategoryDto <span class="cov10" title="47">{
        subCategories := make([]ProjectSubCategoryDto, len(p.SubCategories))
        for i, subCategory := range p.SubCategories </span><span class="cov0" title="0">{
                subCategories[i] = *subCategory.ToProjectSubCategoryDto()
        }</span>

        <span class="cov10" title="47">return &amp;ProjectCategoryDto{
                ID:            p.ID.String(),
                Name:          p.Name,
                SubCategories: subCategories,
        }</span>
}

func (p *ProjectSubCategory) ToProjectSubCategoryDto() *ProjectSubCategoryDto <span class="cov10" title="47">{
        return &amp;ProjectSubCategoryDto{
                ID:   p.ID.String(),
                Name: p.Name,
        }
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package entity

import (
        "time"

        "github.com/google/uuid"
)

type Session struct {
        ID           uuid.UUID `gorm:"primaryKey;type:uuid"`
        UserID       uuid.UUID `gorm:"not null"`
        RefreshToken string    `gorm:"not null"`
        UserAgent    string    `gorm:"not null"`
        ClientIP     string    `gorm:"not null"`
        IsBlocked    bool      `gorm:"default:false;not null"`
        ExpiredAt    time.Time `gorm:"not null"`
}

type SessionDto struct {
        ID           string    `json:"id"`
        UserID       string    `json:"user_id"`
        RefreshToken string    `json:"refresh_token"`
        UserAgent    string    `json:"user_agent"`
        ClientIP     string    `json:"client_ip"`
        IsBlocked    bool      `json:"is_blocked"`
        ExpiredAt    time.Time `json:"expired_at"`
}

// Secondary types

type SessionCreatePayload struct {
        ID           uuid.UUID
        UserID       string
        RefreshToken string
        UserAgent    string
        ClientIP     string
        ExpiredAt    time.Time
} // @name SessionCreatePayload

// Parse functions

func (s *Session) ToSessionDto() *SessionDto <span class="cov10" title="2">{
        return &amp;SessionDto{
                ID:           s.ID.String(),
                UserID:       s.UserID.String(),
                RefreshToken: s.RefreshToken,
                UserAgent:    s.UserAgent,
                ClientIP:     s.ClientIP,
                IsBlocked:    s.IsBlocked,
                ExpiredAt:    s.ExpiredAt,
        }
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package entity

import (
        "time"

        "gorm.io/gorm"
)

type Transaction struct {
        gorm.Model
        RefCode string `gorm:"size:255;not null;unique"`
}

type TransactionCreatePayload struct {
        RefCode string `json:"ref_code" binding:"required"`
} // @name TransactionCreatePayload

type TransactionDto struct {
        ID        uint   `json:"id"`
        RefCode   string `json:"ref_code"`
        CreatedAt string `json:"created_at"`
        UpdatedAt string `json:"updated_at"`
} // @name Transaction

func (t *Transaction) ToTransactionDto() *TransactionDto <span class="cov10" title="2">{
        return &amp;TransactionDto{
                ID:        t.ID,
                RefCode:   t.RefCode,
                CreatedAt: t.CreatedAt.Format(time.RFC3339),
                UpdatedAt: t.UpdatedAt.Format(time.RFC3339),
        }
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package entity

import (
        "fmt"
        "mime/multipart"
        "time"

        "fund-o/api-server/pkg/helper"
)

type UserRole int
type Gender int

const (
        Backer UserRole = iota + 1
        Creator
)

const (
        Male Gender = iota + 1
        Female
        NotSay
)

type User struct {
        Base
        Email             string `gorm:"not null;uniqueIndex"`
        HashedPassword    string `gorm:"not null"`
        Firstname         string `gorm:"not null"`
        Lastname          string `gorm:"not null"`
        DisplayName       string `gorm:"not null"`
        ProfileImage      string
        BirthDate         time.Time `gorm:"not null"`
        Gender            Gender    `gorm:"not null;default:3"`
        MetaMaskAccountID string    `gorm:"default:'empty'"`
        IsEmailVerified   bool      `gorm:"not null;default:false"`
}

type UserDto struct {
        ID                string `json:"id"`
        Email             string `json:"email"`
        FullName          string `json:"full_name"`
        DisplayName       string `json:"display_name"`
        ProfileImage      string `json:"profile_image"`
        BirthDate         string `json:"birthdate"`
        Gender            string `json:"gender"`
        MetamaskAccountID string `json:"metamask_account_id"`
        IsEmailVerified   bool   `json:"is_email_verified"`
        CreatedAt         string `json:"created_at"`
        UpdatedAt         string `json:"updated_at"`
} // @name User

// Secondary types

type UserCreatePayload struct {
        Email                string `json:"email" binding:"required" example:"someemail@gmail.com"`
        Password             string `json:"password" binding:"required" example:"@Password123"`
        PasswordConfirmation string `json:"password_confirmation" binding:"required" example:"@Password123"`
        Firstname            string `json:"firstname" binding:"required" example:"John"`
        Lastname             string `json:"lastname" binding:"required" example:"Doe"`
        BirthDate            string `json:"birthdate" binding:"required" example:"2002-04-16T00:00:00Z"`
        Gender               string `json:"gender" binding:"required" example:"m"`
} // @name UserCreatePayload

type UserUpdatePayload struct {
        Email             string                `form:"email"`
        DisplayName       string                `form:"display_name"`
        ProfileImage      *multipart.FileHeader `form:"profile_image"`
        MetamaskAccountID string                `form:"metamask_account_id"`
        IsEmailVerified   bool                  `form:"is_email_verified"`
} // @name UserUpdatePayload

type UserLoginPayload struct {
        Email    string `json:"email" binding:"required" example:"someemail@gmail.com"`
        Password string `json:"password" binding:"required" example:"@Password123"`
} // @name UserLoginPayload

type UserAuthenticateResponse struct {
        SessionID             string    `json:"session_id"`
        AccessToken           string    `json:"access_token"`
        AccessTokenExpiredAt  time.Time `json:"access_token_expired_at"`
        RefreshToken          string    `json:"refresh_token"`
        RefreshTokenExpiredAt time.Time `json:"refresh_token_expired_at"`
        User                  *UserDto  `json:"user"`
} // @name UserAuthenticateResponse

// Parse functions

func (u *User) ToUserDto() *UserDto <span class="cov10" title="98">{
        return &amp;UserDto{
                ID:                u.ID.String(),
                Email:             u.Email,
                DisplayName:       u.DisplayName,
                FullName:          fmt.Sprintf("%s %s", u.Firstname, u.Lastname),
                ProfileImage:      u.ProfileImage,
                BirthDate:         u.BirthDate.Format(time.RFC3339),
                Gender:            u.Gender.String(),
                IsEmailVerified:   u.IsEmailVerified,
                MetamaskAccountID: u.MetaMaskAccountID,
                CreatedAt:         u.CreatedAt.Format(time.RFC3339),
                UpdatedAt:         u.UpdatedAt.Format(time.RFC3339),
        }
}</span>

func (g Gender) String() string <span class="cov10" title="98">{
        return [...]string{"", "m", "f", "ns"}[g]
}</span>

func (r UserRole) String() string <span class="cov0" title="0">{
        return [...]string{"", "backer", "creator"}[r]
}</span>

var ParseUserRole = func(str string) UserRole <span class="cov0" title="0">{
        mapString := map[string]UserRole{
                "backer":  Backer,
                "creator": Creator,
        }

        role, ok := helper.ParseString[UserRole](mapString, str)
        if !ok </span><span class="cov0" title="0">{
                return Backer
        }</span>

        <span class="cov0" title="0">return role</span>
}

var ParseGender = func(str string) Gender <span class="cov2" title="2">{
        mapString := map[string]Gender{
                "m":  Male,
                "f":  Female,
                "ns": NotSay,
        }

        gender, ok := helper.ParseString(mapString, str)
        if !ok </span><span class="cov0" title="0">{
                return NotSay
        }</span>

        <span class="cov2" title="2">return gender</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package entity

import (
        "time"
)

type VerifyEmail struct {
        Base
        Email      string    `gorm:"not null"`
        SecretCode string    `gorm:"not null"`
        IsUsed     bool      `gorm:"not null;default:false"`
        ExpiredAt  time.Time `gorm:"not null;default:now() + interval '15 minutes'"`
}

type VerifyEmailDto struct {
        ID         string `json:"id"`
        Email      string `json:"email"`
        SecretCode string `json:"secret_code"`
        IsUsed     bool   `json:"is_used"`
        ExpiredAt  string `json:"expired_at"`
} // @name VerifyEmail

// Secondary types

type VerifyEmailCreatePayload struct {
        Email      string `json:"email" binding:"required"`
        SecretCode string `json:"secret_code" binding:"required"`
} // @name VerifyEmailCreatePayload

type VerifyEmailUpdatePayload struct {
        ID         string `json:"id" binding:"required"`
        SecretCode string `json:"secret_code" binding:"required"`
} // @name VerifyEmailUpdatePayload

// Parse functions

func (v *VerifyEmail) ToVerifyEmailDto() *VerifyEmailDto <span class="cov0" title="0">{
        return &amp;VerifyEmailDto{
                ID:         v.ID.String(),
                Email:      v.Email,
                SecretCode: v.SecretCode,
                IsUsed:     v.IsUsed,
                ExpiredAt:  v.ExpiredAt.Format(time.RFC3339),
        }
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package entity

import (
        "encoding/json"
        "github.com/rs/zerolog/log"
)

// ReceivedMessage represents a received websocket message
type ReceivedMessage struct {
        Action  string `json:"action"`
        Room    string `json:"room"`
        Message *any   `json:"message"`
}

// WebsocketMessage represents an emitted message
type WebsocketMessage struct {
        Action string `json:"action"`
        Data   any    `json:"data"`
}

// Encode turns the message into a byte array
func (message *WebsocketMessage) Encode() []byte <span class="cov0" title="0">{
        encoding, err := json.Marshal(message)
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Err(err).Msg("Failed to encode message")
        }</span>

        <span class="cov0" title="0">return encoding</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package handler

import (
        "errors"
        "fmt"
        "fund-o/api-server/cmd/worker"
        "fund-o/api-server/internal/entity"
        "fund-o/api-server/internal/usecase"
        "fund-o/api-server/pkg/apperrors"
        "fund-o/api-server/pkg/password"
        "fund-o/api-server/pkg/token"
        "net/http"
        "time"

        "github.com/hibiken/asynq"

        "github.com/gin-gonic/gin"
        "gorm.io/gorm"
)

type AuthHandlerOptions struct {
        usecase.UserUseCase
        usecase.SessionUseCase
        usecase.VerifyEmailUseCase
        TokenMaker token.Maker
        worker.TaskDistributor
}

type AuthHandler struct {
        userUseCase        usecase.UserUseCase
        sessionUseCase     usecase.SessionUseCase
        verifyEmailUseCase usecase.VerifyEmailUseCase
        tokenMaker         token.Maker
        taskDistributor    worker.TaskDistributor
}

func NewAuthHandler(options *AuthHandlerOptions) *AuthHandler <span class="cov4" title="2">{
        return &amp;AuthHandler{
                userUseCase:        options.UserUseCase,
                sessionUseCase:     options.SessionUseCase,
                verifyEmailUseCase: options.VerifyEmailUseCase,
                tokenMaker:         options.TokenMaker,
                taskDistributor:    options.TaskDistributor,
        }
}</span>

// Register godoc
// @summary Register User
// @description Create user with specific user data and role
// @tags auth
// @id Register
// @accept json
// @produce json
// @param User body entity.UserCreatePayload true "User data to be created"
// @response 200 {object} handler.ResultResponse[entity.UserAuthenticateResponse] "OK"
// @response 400 {object} handler.ErrorResponse "Bad Request"
// @response 500 {object} handler.ErrorResponse "Internal Server Error"
// @router /auth/register [post]
func (h *AuthHandler) Register(c *gin.Context) <span class="cov10" title="6">{
        var user entity.UserCreatePayload
        if err := c.ShouldBindJSON(&amp;user); err != nil </span><span class="cov1" title="1">{
                c.JSON(makeHttpErrorResponse(http.StatusBadRequest, fmt.Sprintf("error register user: %v", err.Error())))
                return
        }</span>

        <span class="cov9" title="5">if user.Password != user.PasswordConfirmation </span><span class="cov1" title="1">{
                c.JSON(makeHttpErrorResponse(http.StatusBadRequest, apperrors.ErrPasswordAndConfirmationNotMatch.Error()))
                return
        }</span>

        <span class="cov7" title="4">birthDate, err := time.Parse(time.RFC3339, user.BirthDate)
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(makeHttpErrorResponse(http.StatusBadRequest, apperrors.ErrInvalidBirthDateFormat.Error()))
                return
        }</span>

        <span class="cov6" title="3">hashedPassword, err := password.HashPassword(user.Password)
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(makeHttpErrorResponse(http.StatusBadRequest, apperrors.ErrHashPassword.Error()))
                return
        }</span>

        <span class="cov4" title="2">userDto, err := h.userUseCase.CreateUser(&amp;entity.User{
                Email:          user.Email,
                Firstname:      user.Firstname,
                Lastname:       user.Lastname,
                DisplayName:    fmt.Sprintf("%s %s", user.Firstname, user.Lastname),
                HashedPassword: hashedPassword,
                BirthDate:      birthDate,
                Gender:         entity.ParseGender(user.Gender),
        })
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(makeHttpErrorResponse(http.StatusInternalServerError, err.Error()))
                return
        }</span>

        <span class="cov1" title="1">accessToken, accessTokenPayload, err := h.tokenMaker.CreateToken(userDto.ID, 15*time.Minute)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(makeHttpErrorResponse(http.StatusInternalServerError, fmt.Sprintf("error authenticate user: %v", err.Error())))
                return
        }</span>

        <span class="cov1" title="1">refreshToken, refreshTokenPayload, err := h.tokenMaker.CreateToken(userDto.ID, 24*time.Hour)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(makeHttpErrorResponse(http.StatusInternalServerError, fmt.Sprintf("error authenticate user: %v", err.Error())))
                return
        }</span>

        <span class="cov1" title="1">session, err := h.sessionUseCase.CreateSession(&amp;entity.SessionCreatePayload{
                ID:           refreshTokenPayload.ID,
                UserID:       userDto.ID,
                RefreshToken: refreshToken,
                UserAgent:    c.Request.UserAgent(),
                ClientIP:     c.ClientIP(),
                ExpiredAt:    refreshTokenPayload.ExpiredAt,
        })
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(makeHttpErrorResponse(http.StatusInternalServerError, fmt.Sprintf("error authenticate user: %v", err.Error())))
                return
        }</span>

        <span class="cov1" title="1">response := entity.UserAuthenticateResponse{
                SessionID:             session.ID,
                AccessToken:           accessToken,
                AccessTokenExpiredAt:  accessTokenPayload.ExpiredAt,
                RefreshToken:          refreshToken,
                RefreshTokenExpiredAt: refreshTokenPayload.ExpiredAt,
                User:                  userDto,
        }

        c.JSON(makeHttpResponse(http.StatusCreated, response))</span>
}

// Login godoc
// @summary Authenticate User
// @description Authenticate user with email and password
// @tags auth
// @id Login
// @accept json
// @produce json
// @param User body entity.UserLoginPayload true "User data to be authenticated"
// @response 200 {object} handler.ResultResponse[entity.UserAuthenticateResponse] "OK"
// @response 400 {object} handler.ErrorResponse "Bad Request"
// @response 500 {object} handler.ErrorResponse "Internal Server Error"
// @router /auth/login [post]
func (h *AuthHandler) Login(c *gin.Context) <span class="cov6" title="3">{
        var req entity.UserLoginPayload
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov1" title="1">{
                c.JSON(makeHttpErrorResponse(http.StatusBadRequest, fmt.Sprintf("error authenticate user: %v", err.Error())))
                return
        }</span>

        <span class="cov4" title="2">user, err := h.userUseCase.AuthenticateUser(&amp;req)
        if err != nil </span><span class="cov1" title="1">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov1" title="1">{
                        c.JSON(makeHttpErrorResponse(http.StatusNotFound, fmt.Sprintf("error authenticate user: %v", err.Error())))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(makeHttpErrorResponse(http.StatusInternalServerError, fmt.Sprintf("error authenticate user: %v", err.Error())))
                return</span>
        }

        <span class="cov1" title="1">accessToken, accessTokenPayload, err := h.tokenMaker.CreateToken(user.ID, 15*time.Minute)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(makeHttpErrorResponse(http.StatusInternalServerError, fmt.Sprintf("error authenticate user: %v", err.Error())))
                return
        }</span>

        <span class="cov1" title="1">refreshToken, refreshTokenPayload, err := h.tokenMaker.CreateToken(user.ID, 24*time.Hour)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(makeHttpErrorResponse(http.StatusInternalServerError, fmt.Sprintf("error authenticate user: %v", err.Error())))
                return
        }</span>

        <span class="cov1" title="1">session, err := h.sessionUseCase.CreateSession(&amp;entity.SessionCreatePayload{
                ID:           refreshTokenPayload.ID,
                UserID:       user.ID,
                RefreshToken: refreshToken,
                UserAgent:    c.Request.UserAgent(),
                ClientIP:     c.ClientIP(),
                ExpiredAt:    refreshTokenPayload.ExpiredAt,
        })
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(makeHttpErrorResponse(http.StatusInternalServerError, fmt.Sprintf("error authenticate user: %v", err.Error())))
                return
        }</span>

        <span class="cov1" title="1">response := entity.UserAuthenticateResponse{
                SessionID:             session.ID,
                AccessToken:           accessToken,
                AccessTokenExpiredAt:  accessTokenPayload.ExpiredAt,
                RefreshToken:          refreshToken,
                RefreshTokenExpiredAt: refreshTokenPayload.ExpiredAt,
                User:                  user,
        }

        c.JSON(makeHttpResponse(http.StatusOK, response))</span>
}

type RenewAccessTokenPayload struct {
        RefreshToken string `json:"refresh_token" binding:"required"`
}

type RenewAccessTokenResponse struct {
        AccessToken          string    `json:"access_token"`
        AccessTokenExpiredAt time.Time `json:"access_token_expired_at"`
}

// RenewAccessToken godoc
// @summary Renew Access Token
// @description Renew access token with refresh token
// @tags auth
// @id RenewAccessToken
// @accept json
// @produce json
// @param User body handler.RenewAccessTokenPayload true "Refresh token to be renewed"
// @response 200 {object} handler.ResultResponse[handler.RenewAccessTokenResponse] "OK"
// @response 400 {object} handler.ErrorResponse "Bad Request"
// @response 500 {object} handler.ErrorResponse "Internal Server Error"
// @router /auth/renew-token [post]
func (h *AuthHandler) RenewAccessToken(c *gin.Context) <span class="cov0" title="0">{
        var req RenewAccessTokenPayload
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(makeHttpErrorResponse(http.StatusBadRequest, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">refreshTokenPayload, err := h.tokenMaker.VerifyToken(req.RefreshToken)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(makeHttpErrorResponse(http.StatusBadRequest, err.Error()))
        }</span>

        <span class="cov0" title="0">session, err := h.sessionUseCase.GetSessionByID(refreshTokenPayload.ID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        c.JSON(makeHttpErrorResponse(http.StatusNotFound, err.Error()))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(makeHttpErrorResponse(http.StatusBadRequest, err.Error()))
                return</span>
        }

        <span class="cov0" title="0">if session.IsBlocked </span><span class="cov0" title="0">{
                err := fmt.Errorf("blocked session")
                c.JSON(makeHttpErrorResponse(http.StatusBadRequest, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">if session.UserID != refreshTokenPayload.UserID </span><span class="cov0" title="0">{
                err := fmt.Errorf("mismatch session token")
                c.JSON(makeHttpErrorResponse(http.StatusBadRequest, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">if time.Now().After(session.ExpiredAt) </span><span class="cov0" title="0">{
                err := fmt.Errorf("session expired")
                c.JSON(makeHttpErrorResponse(http.StatusBadRequest, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">accessToken, accessTokenPayload, err := h.tokenMaker.CreateToken(refreshTokenPayload.UserID, 15*time.Minute)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(makeHttpErrorResponse(http.StatusInternalServerError, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">response := RenewAccessTokenResponse{
                AccessToken:          accessToken,
                AccessTokenExpiredAt: accessTokenPayload.ExpiredAt,
        }

        c.JSON(makeHttpResponse(http.StatusOK, response))</span>
}

type SendVerifyEmailPayload struct {
        Email string `json:"email" binding:"required"`
}

// SendVerifyEmail godoc
// @summary Send Verify Email
// @description Send verify email to user email
// @tags auth
// @id SendVerifyEmail
// @accept json
// @produce json
// @param User body handler.SendVerifyEmailPayload true "User email to be verified"
// @response 200 {object} handler.MessageResponse "OK"
// @response 400 {object} handler.ErrorResponse "Bad Request"
// @response 500 {object} handler.ErrorResponse "Internal Server Error"
// @router /auth/send-verify-email [post]
func (h *AuthHandler) SendVerifyEmail(c *gin.Context) <span class="cov0" title="0">{
        var req SendVerifyEmailPayload

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(makeHttpErrorResponse(http.StatusBadRequest, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">user, err := h.userUseCase.GetUserByEmail(req.Email)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(makeHttpErrorResponse(http.StatusBadRequest, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">if user.IsEmailVerified </span><span class="cov0" title="0">{
                c.JSON(makeHttpErrorResponse(http.StatusBadRequest, "email already verified"))
                return
        }</span>

        <span class="cov0" title="0">taskPayload := &amp;worker.PayloadSendVerifyEmail{
                Email: user.Email,
        }

        opts := []asynq.Option{
                asynq.MaxRetry(10),
                asynq.ProcessIn(3 * time.Second),
                asynq.Queue(worker.QueueCritical),
        }

        h.taskDistributor.DistributeTaskSendVerifyEmail(c, taskPayload, opts...)

        c.JSON(makeHttpMessageResponse(http.StatusOK, "verify email sent"))</span>
}

// VerifyEmail godoc
// @summary Verify Email
// @description Verify email with email id and secret code
// @tags auth
// @id VerifyEmail
// @accept json
// @produce json
// @param email_id query string true "Email ID to be verified"
// @param secret_code query string true "Secret Code to be verified"
// @response 200 {object} handler.ResultResponse[entity.UserDto] "OK"
// @response 400 {object} handler.ErrorResponse "Bad Request"
// @response 500 {object} handler.ErrorResponse "Internal Server Error"
// @router /auth/verify-email [get]
func (h *AuthHandler) VerifyEmail(c *gin.Context) <span class="cov0" title="0">{
        emailID := c.Query("email_id")
        secretCode := c.Query("secret_code")

        if emailID == "" || secretCode == "" </span><span class="cov0" title="0">{
                c.JSON(makeHttpErrorResponse(http.StatusBadRequest, "invalid email id or secret code"))
                return
        }</span>

        <span class="cov0" title="0">payload := entity.VerifyEmailUpdatePayload{
                ID:         emailID,
                SecretCode: secretCode,
        }

        verifyEmail, err := h.verifyEmailUseCase.VerifyEmail(&amp;payload)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(makeHttpErrorResponse(http.StatusBadRequest, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">user, err := h.userUseCase.GetUserByEmail(verifyEmail.Email)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(makeHttpErrorResponse(http.StatusBadRequest, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">updatedUser, err := h.userUseCase.UpdateUserByID(user.ID, &amp;entity.UserUpdatePayload{
                IsEmailVerified: true,
        })
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(makeHttpErrorResponse(http.StatusBadRequest, err.Error()))
                return
        }</span>

        // TODO: navigate to frontend page instead
        <span class="cov0" title="0">c.Redirect(http.StatusFound, "http://localhost:5173/profile")
        c.JSON(makeHttpResponse(http.StatusOK, updatedUser))</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package handler

import (
        "errors"
        "fmt"
        "fund-o/api-server/cmd/ws"
        "fund-o/api-server/internal/entity"
        "fund-o/api-server/internal/http/middleware"
        "fund-o/api-server/internal/usecase"
        "fund-o/api-server/pkg/token"
        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "net/http"
)

type ChatHandler struct {
        channelUsecase usecase.ChannelUsecase
        messageUsecase usecase.MessageUsecase
        socketService  ws.SocketService
}

type ChatHandlerOptions struct {
        usecase.ChannelUsecase
        usecase.MessageUsecase
        ws.SocketService
}

func NewChatHandler(options *ChatHandlerOptions) *ChatHandler <span class="cov0" title="0">{
        return &amp;ChatHandler{
                channelUsecase: options.ChannelUsecase,
                messageUsecase: options.MessageUsecase,
                socketService:  options.SocketService,
        }
}</span>

// GetOrCreateChannel Godoc
// @summary Get or create a channel
// @description Get or create a channel
// @tags chat
// @accept json
// @produce json
// @security ApiKeyAuth
// @param id path string true "Recipient ID"
// @success 200 {object} handler.ResultResponse[entity.ChannelDto] "OK"
// @failure 401 {object} handler.ErrorResponse "Unauthorized"
// @failure 500 {object} handler.ErrorResponse "Internal Server Error"
// @router /channels/{id} [get]
func (h *ChatHandler) GetOrCreateChannel(c *gin.Context) <span class="cov0" title="0">{
        userID := c.MustGet(middleware.AuthorizationPayloadKey).(*token.Payload).UserID
        channelID := c.Param("id")

        // Check if channel already exists
        existingChannel, err := h.channelUsecase.GetExistingChannel(userID, channelID)
        if err == nil </span><span class="cov0" title="0">{
                fmt.Println("Existing Channel: ", existingChannel)
                c.JSON(makeHttpResponse(http.StatusOK, existingChannel))
                return
        }</span>

        <span class="cov0" title="0">var payload entity.ChannelCreatePayload
        payload.Name = fmt.Sprintf("%s_%s", userID, channelID)
        payload.Members = []string{userID, channelID}

        channel, err := h.channelUsecase.CreateChannel(&amp;payload)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(makeHttpErrorResponse(http.StatusInternalServerError, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">c.JSON(makeHttpResponse(http.StatusOK, channel))</span>
}

func (h *ChatHandler) GetOwnChannels(c *gin.Context) <span class="cov0" title="0">{
        userID := c.MustGet(middleware.AuthorizationPayloadKey).(*token.Payload).UserID

        channels, err := h.channelUsecase.GetChannelByUserID(userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(makeHttpErrorResponse(http.StatusInternalServerError, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">response := make([]entity.GetOwnChannelsResponse, len(channels))
        for i, c := range channels </span><span class="cov0" title="0">{
                var receiver entity.UserDto
                for _, m := range c.Members </span><span class="cov0" title="0">{
                        if m.ID != userID </span><span class="cov0" title="0">{
                                receiver = m
                                fmt.Println("Receiver: ", m)
                        }</span>
                }
                <span class="cov0" title="0">if len(c.Messages) == 0 </span><span class="cov0" title="0">{
                        response[i] = entity.GetOwnChannelsResponse{
                                Receiver:    receiver,
                                LastMessage: nil,
                        }
                }</span> else<span class="cov0" title="0"> {
                        response[i] = entity.GetOwnChannelsResponse{
                                Receiver:    receiver,
                                LastMessage: &amp;c.Messages[len(c.Messages)-1],
                        }
                }</span>
        }

        <span class="cov0" title="0">c.JSON(makeHttpResponse(http.StatusOK, response))</span>
}

func (h *ChatHandler) SendMessage(c *gin.Context) <span class="cov0" title="0">{
        userID := c.MustGet(middleware.AuthorizationPayloadKey).(*token.Payload).UserID
        channelID := c.Param("id")

        var payload entity.MessageCreatePayload
        if err := c.ShouldBind(&amp;payload); err != nil </span><span class="cov0" title="0">{
                c.JSON(makeHttpErrorResponse(http.StatusBadRequest, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">channel, err := h.channelUsecase.GetExistingChannel(userID, channelID)
        if err != nil </span><span class="cov0" title="0">{
                err := errors.New("channel not found")
                c.JSON(makeHttpErrorResponse(http.StatusNotFound, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">authorID, err := uuid.Parse(userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(makeHttpErrorResponse(http.StatusInternalServerError, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">parsedChannelID, err := uuid.Parse(channel.ID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(makeHttpErrorResponse(http.StatusInternalServerError, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">message, err := h.messageUsecase.CreateChannelMessage(parsedChannelID, &amp;entity.MessageCreatePayload{
                Text:       payload.Text,
                Attachment: payload.Attachment,
                AuthorID:   authorID,
        })
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(makeHttpErrorResponse(http.StatusInternalServerError, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">h.socketService.EmitNewMessage(channel.Name, message)

        c.JSON(makeHttpResponse(http.StatusOK, message))</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package handler

import (
        "fmt"
        "fund-o/api-server/internal/entity"
        "fund-o/api-server/internal/http/middleware"
        "fund-o/api-server/internal/usecase"
        "fund-o/api-server/pkg/pagination"
        "fund-o/api-server/pkg/token"
        "github.com/gin-gonic/gin"
        "mime/multipart"
        "net/http"
)

type ForumHandler struct {
        forumUseCase usecase.ForumUseCase
}

type ForumHandlerOptions struct {
        usecase.ForumUseCase
}

func NewForumHandler(options *ForumHandlerOptions) *ForumHandler <span class="cov1" title="1">{
        return &amp;ForumHandler{
                forumUseCase: options.ForumUseCase,
        }
}</span>

// ListPosts godoc
// @summary List Posts
// @description List posts
// @tags forums
// @id ListPosts
// @accept json
// @produce json
// @param page query int false "number of page"
// @param size query int false "size of data per page"
// @success 200 {object} handler.ResultResponse[pagination.PaginateResult[entity.PostDto]] "OK"
// @failure 500 {object} handler.ErrorResponse "Internal Server Error"
// @router /posts [get]
func (h *ForumHandler) ListPosts(c *gin.Context) <span class="cov10" title="4">{
        var paginateOptions pagination.PaginateOptions
        if err := c.ShouldBindQuery(&amp;paginateOptions); err != nil </span><span class="cov1" title="1">{
                c.JSON(makeHttpErrorResponse(http.StatusBadRequest, fmt.Sprintf("error list forums: %v", err.Error())))
                return
        }</span>

        <span class="cov8" title="3">forums := h.forumUseCase.ListForums(paginateOptions)
        c.JSON(makeHttpResponse(http.StatusOK, forums))</span>
}

// CreatePost godoc
// @summary Create Post
// @description Create post
// @tags forums
// @id CreatePost
// @accept json
// @produce json
// @security ApiKeyAuth
// @param payload body entity.PostCreatePayload true "post payload"
// @success 201 {object} handler.ResultResponse[entity.PostDto]
// @failure 400 {object} handler.ErrorResponse
// @failure 500 {object} handler.ErrorResponse
// @router /posts [post]
func (h *ForumHandler) CreatePost(c *gin.Context) <span class="cov8" title="3">{
        userID := c.MustGet(middleware.AuthorizationPayloadKey).(*token.Payload).UserID
        var req entity.PostCreatePayload
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov1" title="1">{
                c.JSON(makeHttpErrorResponse(http.StatusBadRequest, fmt.Sprintf("error create forum: %v", err.Error())))
                return
        }</span>

        <span class="cov5" title="2">req.AuthorID = userID

        forumDto, err := h.forumUseCase.CreatePost(&amp;req)
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(makeHttpErrorResponse(http.StatusInternalServerError, fmt.Sprintf("error create forum: %v", err.Error())))
                return
        }</span>

        <span class="cov1" title="1">c.JSON(makeHttpResponse(http.StatusCreated, forumDto))</span>
}

// GetPostByID godoc
// @summary Get Post by ID
// @description Get post by id
// @tags forums
// @id GetPostByID
// @accept json
// @produce json
// @param id path string true "post id to get"
// @success 200 {object} handler.ResultResponse[entity.PostDto]
// @failure 500 {object} handler.ErrorResponse
// @router /posts/{id} [get]
func (h *ForumHandler) GetPostByID(c *gin.Context) <span class="cov5" title="2">{
        id := c.Param("id")
        forumDto, err := h.forumUseCase.GetPostByID(id)
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(makeHttpErrorResponse(http.StatusInternalServerError, fmt.Sprintf("error get forum by id: %v", err.Error())))
                return
        }</span>

        <span class="cov1" title="1">c.JSON(makeHttpResponse(http.StatusOK, forumDto))</span>
}

// CreateComment godoc
// @summary Create Comment
// @description Create comment for forum
// @tags forums
// @id CreateComment
// @accept json
// @produce json
// @security ApiKeyAuth
// @param id path string true "forum id to comment"
// @param payload body entity.CommentCreatePayload true "comment payload"
// @success 201 {object} handler.ResultResponse[entity.CommentDto]
// @failure 400 {object} handler.ErrorResponse
// @failure 500 {object} handler.ErrorResponse
// @router /posts/{id}/comments [post]
func (h *ForumHandler) CreateComment(c *gin.Context) <span class="cov0" title="0">{
        userID := c.MustGet(middleware.AuthorizationPayloadKey).(*token.Payload).UserID
        forumID := c.Param("id")
        var req entity.CommentCreatePayload
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(makeHttpErrorResponse(http.StatusBadRequest, fmt.Sprintf("error create comment: %v", err.Error())))
                return
        }</span>

        <span class="cov0" title="0">req.AuthorID = userID

        commentDto, err := h.forumUseCase.CreateCommentByForumID(forumID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(makeHttpErrorResponse(http.StatusInternalServerError, fmt.Sprintf("error create comment: %v", err.Error())))
                return
        }</span>

        <span class="cov0" title="0">c.JSON(makeHttpResponse(http.StatusCreated, commentDto))</span>
}

// CreateReply godoc
// @summary Create Reply
// @description Create reply for comment
// @tags forums
// @id CreateReply
// @accept json
// @produce json
// @security ApiKeyAuth
// @param id path string true "comment id to reply"
// @param payload body entity.ReplyCreatePayload true "reply payload"
// @success 201 {object} handler.ResultResponse[entity.ReplyDto]
// @failure 400 {object} handler.ErrorResponse
// @failure 500 {object} handler.ErrorResponse
// @router /comments/{id}/replies [post]
func (h *ForumHandler) CreateReply(c *gin.Context) <span class="cov0" title="0">{
        userID := c.MustGet(middleware.AuthorizationPayloadKey).(*token.Payload).UserID
        commentID := c.Param("id")
        var req entity.ReplyCreatePayload
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(makeHttpErrorResponse(http.StatusBadRequest, fmt.Sprintf("error create reply: %v", err.Error())))
                return
        }</span>

        <span class="cov0" title="0">req.AuthorID = userID

        replyDto, err := h.forumUseCase.CreateReplyByCommentID(commentID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(makeHttpErrorResponse(http.StatusInternalServerError, fmt.Sprintf("error create reply: %v", err.Error())))
                return
        }</span>

        <span class="cov0" title="0">c.JSON(makeHttpResponse(http.StatusCreated, replyDto))</span>
}

// UploadImage godoc
// @summary Upload Post Image
// @description Upload post image
// @tags forums
// @id UploadImage
// @accept json
// @produce json
// @security ApiKeyAuth
// @param image formData file true "post image file"
// @failure 400 {object} handler.ErrorResponse
// @failure 500 {object} handler.ErrorResponse
// @router /posts/upload [post]
func (h *ForumHandler) UploadImage(c *gin.Context) <span class="cov0" title="0">{
        var req struct {
                Image *multipart.FileHeader `form:"image" binding:"required"`
        }

        if err := c.ShouldBind(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(makeHttpErrorResponse(http.StatusBadRequest, fmt.Sprintf("error upload post image: %v", err.Error())))
                return
        }</span>

        <span class="cov0" title="0">imageUrl, uploadError := h.forumUseCase.UploadPostImage(req.Image)
        if uploadError != nil </span><span class="cov0" title="0">{
                c.JSON(makeHttpErrorResponse(uploadError.Status(), uploadError.Error()))
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success": 1,
                "file": gin.H{
                        "url": imageUrl,
                },
        })</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package handler

import (
        "fmt"
        "net/http"

        "github.com/gin-gonic/gin"
)

// GetHelloMessageHandler godoc
// @summary Health Check
// @description Health checking for the service
// @tags healthcheck
// @id GetHelloMessageHandler
// @produce json
// @param name query string false "name of the active user"
// @response 200 {object} handler.MessageResponse "OK"
// @router /hello [get]
func GetHelloMessage(c *gin.Context) <span class="cov10" title="2">{
        name := c.Query("name")

        if name != "" </span><span class="cov1" title="1">{
                c.JSON(makeHttpMessageResponse(http.StatusOK, fmt.Sprintf("Hello, %s!", name)))
                return
        }</span>

        <span class="cov1" title="1">c.JSON(makeHttpMessageResponse(http.StatusOK, "Hello, Guest!"))</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package handler

import (
        "fmt"
        "fund-o/api-server/internal/entity"
        "fund-o/api-server/internal/http/middleware"
        "fund-o/api-server/internal/usecase"
        "fund-o/api-server/pkg/token"
        "github.com/shopspring/decimal"
        "net/http"

        "github.com/gin-gonic/gin"
)

type ProjectHandler struct {
        projectUseCase         usecase.ProjectUseCase
        projectCategoryUseCase usecase.ProjectCategoryUseCase
        userUseCase            usecase.UserUseCase
}

type ProjectHandlerOptions struct {
        usecase.ProjectUseCase
        usecase.ProjectCategoryUseCase
        usecase.UserUseCase
}

func NewProjectHandler(options *ProjectHandlerOptions) *ProjectHandler <span class="cov0" title="0">{
        return &amp;ProjectHandler{
                projectUseCase:         options.ProjectUseCase,
                projectCategoryUseCase: options.ProjectCategoryUseCase,
                userUseCase:            options.UserUseCase,
        }
}</span>

// ListProjects godoc
// @summary List Projects
// @description List projects
// @tags projects
// @id ListProjects
// @accept json
// @produce json
// @param page query int false "number of page"
// @param size query int false "size of data per page"
// @response 200 {object} handler.ResultResponse[pagination.PaginateResult[entity.ProjectDto]] "OK"
// @response 400 {object} handler.ErrorResponse "Bad Request"
// @response 500 {object} handler.ErrorResponse "Internal Server Error"
// @router /projects [get]
func (h *ProjectHandler) ListProjects(c *gin.Context) <span class="cov0" title="0">{
        var params entity.ProjectListParams
        if err := c.ShouldBindQuery(&amp;params); err != nil </span><span class="cov0" title="0">{
                c.JSON(makeHttpErrorResponse(http.StatusBadRequest, fmt.Sprintf("error list forums: %v", err.Error())))
                return
        }</span>

        <span class="cov0" title="0">projects := h.projectUseCase.ListProjects(params)
        c.JSON(makeHttpResponse(http.StatusOK, projects))</span>
}

// CreateProject godoc
// @summary Create Project
// @description Create project with required data
// @tags projects
// @id CreateProject
// @accept mpfd
// @produce json
// @security ApiKeyAuth
// @param Project body entity.ProjectCreatePayload true "Project data to be created"
// @response 200 {object} handler.ResultResponse[entity.ProjectDto] "OK"
// @response 400 {object} handler.ErrorResponse "Bad Request"
// @response 500 {object} handler.ErrorResponse "Internal Server Error"
// @router /projects [post]
func (h *ProjectHandler) CreateProject(c *gin.Context) <span class="cov0" title="0">{
        userID := c.MustGet(middleware.AuthorizationPayloadKey).(*token.Payload).UserID

        var req entity.ProjectCreatePayload
        if err := c.ShouldBind(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(makeHttpErrorResponse(http.StatusBadRequest, fmt.Sprintf("error create project: %v", err.Error())))
                return
        }</span>

        <span class="cov0" title="0">user, err := h.userUseCase.GetUserById(userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(makeHttpErrorResponse(http.StatusBadRequest, fmt.Sprintf("error create project: %v", err.Error())))
                return
        }</span>

        <span class="cov0" title="0">req.OwnerID = user.ID

        projectDto, err := h.projectUseCase.CreateProject(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(makeHttpErrorResponse(http.StatusInternalServerError, fmt.Sprintf("error create project: %v", err.Error())))
                return
        }</span>

        <span class="cov0" title="0">projectDto.Owner = user

        c.JSON(makeHttpResponse(http.StatusCreated, projectDto))</span>
}

// GetProjectByID godoc
// @summary Get Project by ID
// @description Get project by ID
// @tags projects
// @id GetProjectByID
// @accept json
// @produce json
// @param id path string true "Project ID"
// @response 200 {object} handler.ResultResponse[entity.ProjectDto] "OK"
// @response 400 {object} handler.ErrorResponse "Bad Request"
// @response 500 {object} handler.ErrorResponse "Internal Server Error"
// @router /projects/{id} [get]
func (h *ProjectHandler) GetProjectByID(c *gin.Context) <span class="cov0" title="0">{
        projectID := c.Param("id")

        projectDto, err := h.projectUseCase.GetProjectByID(projectID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(makeHttpErrorResponse(err.Status(), err.Error()))
                return
        }</span>

        <span class="cov0" title="0">c.JSON(makeHttpResponse(http.StatusOK, projectDto))</span>
}

// GetOwnProjects godoc
// @summary Get own Projects
// @description Get own projects with authenticate creator
// @tags projects
// @id GetOwnProjects
// @accpet json
// @produce json
// @security ApiKeyAuth
// @response 200 {object} handler.ResultResponse[[]entity.ProjectDto] "OK"
// @response 400 {object} handler.ErrorResponse "Bad Request"
// @response 500 {object} handler.ErrorResponse "Internal Server Error"
// @router /projects/me [get]
func (h *ProjectHandler) GetOwnProjects(c *gin.Context) <span class="cov0" title="0">{
        userID := c.MustGet(middleware.AuthorizationPayloadKey).(*token.Payload).UserID

        projectDtos, err := h.projectUseCase.GetProjectsByOwnerID(userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(makeHttpErrorResponse(http.StatusInternalServerError, fmt.Sprintf("error create project: %v", err.Error())))
                return
        }</span>

        <span class="cov0" title="0">c.JSON(makeHttpResponse(http.StatusOK, projectDtos))</span>
}

func (h *ProjectHandler) GetRecommendProjects(c *gin.Context) <span class="cov0" title="0">{
        projects, err := h.projectUseCase.GetRecommendationProjects()
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(makeHttpErrorResponse(http.StatusInternalServerError, fmt.Sprintf("error get recommendation projects: %v", err.Error())))
                return
        }</span>

        <span class="cov0" title="0">c.JSON(makeHttpResponse(http.StatusOK, projects))</span>
}

// ListProjectCategories godoc
// @summary List Project Categories
// @description List project categories for selection
// @tags projects
// @id ListProjectCategories
// @produce json
// @response 200 {object} handler.ResultResponse[[]entity.ProjectCategoryDto]
// @response 500 {object} handler.ErrorResponse "Internal Server Error"
// @router /projects/categories [get]
func (h *ProjectHandler) ListProjectCategories(c *gin.Context) <span class="cov0" title="0">{
        categories, err := h.projectCategoryUseCase.ListProjectCategories()
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(makeHttpErrorResponse(http.StatusInternalServerError, fmt.Sprintf("error list project categories: %v", err.Error())))
                return
        }</span>

        <span class="cov0" title="0">c.JSON(makeHttpResponse(http.StatusOK, categories))</span>
}

// CreateProjectRating godoc
// @summary Create Project Rating
// @description Create project rating with required data
// @tags projects
// @id CreateProjectRating
// @accept json
// @produce json
// @security ApiKeyAuth
// @param id path string true "Project ID"
// @param ProjectRating body entity.ProjectRatingCreatePayload true "Project rating data to be created"
// @response 201 {object} handler.ResultResponse[entity.ProjectDto] "Created"
// @response 400 {object} handler.ErrorResponse "Bad Request"
// @response 500 {object} handler.ErrorResponse "Internal Server Error"
// @router /projects/{id}/ratings [post]
func (h *ProjectHandler) CreateProjectRating(c *gin.Context) <span class="cov0" title="0">{
        projectID := c.Param("id")
        userID := c.MustGet(middleware.AuthorizationPayloadKey).(*token.Payload).UserID

        var req entity.ProjectRatingCreatePayload
        req.ProjectID = projectID
        req.UserID = userID

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(makeHttpErrorResponse(http.StatusBadRequest, fmt.Sprintf("error create project rating: %v", err.Error())))
                return
        }</span>

        <span class="cov0" title="0">err := h.projectUseCase.CreateProjectRating(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(makeHttpErrorResponse(http.StatusInternalServerError, fmt.Sprintf("error create project rating: %v", err.Error())))
                return
        }</span>

        <span class="cov0" title="0">c.JSON(makeHttpMessageResponse(http.StatusCreated, "user rated project successfully"))</span>
}

// VerifyProjectRating godoc
// @summary Verify Project Rating
// @description Verify project rating by user
// @tags projects
// @id VerifyProjectRating
// @accept json
// @produce json
// @security ApiKeyAuth
// @param id path string true "Project ID"
// @response 200 {object} handler.ResultResponse[bool] "OK"
// @response 500 {object} handler.ErrorResponse "Internal Server Error"
// @router /projects/{id}/ratings/verify [get]
func (h *ProjectHandler) VerifyProjectRating(c *gin.Context) <span class="cov0" title="0">{
        projectID := c.Param("id")
        userID := c.MustGet(middleware.AuthorizationPayloadKey).(*token.Payload).UserID

        rated, err := h.projectUseCase.IsRatedProject(userID, projectID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(makeHttpErrorResponse(http.StatusInternalServerError, fmt.Sprintf("error verify project rating: %v", err.Error())))
                return
        }</span>

        <span class="cov0" title="0">c.JSON(makeHttpResponse(http.StatusOK, rated))</span>
}

func (h *ProjectHandler) ContributeProject(c *gin.Context) <span class="cov0" title="0">{
        projectID := c.Param("id")
        userID := c.MustGet(middleware.AuthorizationPayloadKey).(*token.Payload).UserID

        var req entity.ProjectBackerCreatePayload
        req.ProjectID = projectID

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(makeHttpErrorResponse(http.StatusBadRequest, fmt.Sprintf("error create project rating: %v", err.Error())))
                return
        }</span>

        <span class="cov0" title="0">err := h.projectUseCase.CreateBackProject(userID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(makeHttpErrorResponse(http.StatusInternalServerError, fmt.Sprintf("error create project rating: %v", err.Error())))
                return
        }</span>

        <span class="cov0" title="0">c.JSON(makeHttpMessageResponse(http.StatusCreated, "user backed project successfully"))</span>
}

type GetBackedProjectResponse struct {
        Funded  decimal.Decimal   `json:"funded"`
        Project entity.ProjectDto `json:"project"`
}

func (h *ProjectHandler) GetBackedProject(c *gin.Context) <span class="cov0" title="0">{
        userID := c.MustGet(middleware.AuthorizationPayloadKey).(*token.Payload).UserID

        backers, err := h.projectUseCase.GetBackedProjects(userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(makeHttpErrorResponse(http.StatusInternalServerError, fmt.Sprintf("error get project backer: %v", err.Error())))
                return
        }</span>

        <span class="cov0" title="0">c.JSON(makeHttpResponse(http.StatusOK, backers))</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package handler

import "net/http"

type ResultResponse[T any] struct {
        Status     string `json:"status"`
        StatusCode int    `json:"status_code"`
        Result     T      `json:"result"`
} // @name ResultResponse

type MessageResponse struct {
        Status     string `json:"status"`
        StatusCode int    `json:"status_code"`
        Message    string `json:"message"`
} // @name MessageResponse

type ErrorResponse struct {
        Status     string `json:"status"`
        StatusCode int    `json:"status_code"`
        Error      string `json:"error"`
} // @name ErrorResponse

func makeHttpResponse[T any](code int, result T) (int, ResultResponse[T]) <span class="cov8" title="11">{
        response := ResultResponse[T]{
                Status:     http.StatusText(code),
                StatusCode: code,
                Result:     result,
        }

        return code, response
}</span>

func makeHttpMessageResponse(code int, message string) (int, MessageResponse) <span class="cov3" title="2">{
        response := MessageResponse{
                Status:     http.StatusText(code),
                StatusCode: code,
                Message:    message,
        }

        return code, response
}</span>

func makeHttpErrorResponse(code int, err string) (int, ErrorResponse) <span class="cov10" title="18">{
        response := ErrorResponse{
                Status:     http.StatusText(code),
                StatusCode: code,
                Error:      err,
        }

        return code, response
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">package handler

import (
        "fmt"
        "net/http"

        "fund-o/api-server/internal/entity"
        "fund-o/api-server/internal/usecase"
        "fund-o/api-server/pkg/pagination"

        "github.com/gin-gonic/gin"
        "gorm.io/gorm"
)

type TransactionHandlerOptions struct {
        TransactionUseCase usecase.TransactionUseCase
}

type TransactionHandler struct {
        transactionUseCase usecase.TransactionUseCase
}

func NewTransactionHandler(options *TransactionHandlerOptions) *TransactionHandler <span class="cov10" title="2">{
        return &amp;TransactionHandler{
                transactionUseCase: options.TransactionUseCase,
        }
}</span>

// CreateTransaction godoc
// @summary Create Transaction
// @description Create transaction with reference code
// @tags transasctions
// @id CreateTransaction
// @accpet json
// @produce json
// @param Transaction body entity.TransactionCreatePayload true "Transaction data to be created"
// @response 200 {object} handler.ResultResponse[entity.TransactionDto] "OK"
// @response 400 {object} handler.ErrorResponse "Bad Request"
// @response 500 {object} handler.ErrorResponse "Internal Server Error"
// @router /transactions [post]
func (handler *TransactionHandler) CreateTransaction(c *gin.Context) <span class="cov10" title="2">{
        var transaction entity.TransactionCreatePayload
        if err := c.ShouldBindJSON(&amp;transaction); err != nil </span><span class="cov1" title="1">{
                c.JSON(makeHttpErrorResponse(http.StatusBadRequest, fmt.Sprintf("error create transaction: %v", err.Error())))
                return
        }</span>

        <span class="cov1" title="1">transactionDto, err := handler.transactionUseCase.CreateTransaction(&amp;transaction)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(makeHttpErrorResponse(http.StatusInternalServerError, fmt.Sprintf("error create transaction: %v", err.Error())))
                return
        }</span>

        <span class="cov1" title="1">c.JSON(makeHttpResponse(http.StatusCreated, transactionDto))</span>
}

// GetTransaction godoc
// @summary Get Transaction
// @description Get transaction by id
// @tags transasctions
// @id GetTransaction
// @produce json
// @param id path string true "reference code of transaction"
// @response 200 {object} handler.ResultResponse[entity.TransactionDto] "OK"
// @response 500 {object} handler.ErrorResponse "Internal Server Error"
// @router /transactions/{id} [get]
func (handler *TransactionHandler) GetTransaction(c *gin.Context) <span class="cov10" title="2">{
        transactionRefCode := c.Param("id")

        transactionDto, err := handler.transactionUseCase.GetTransactionByRefCode(transactionRefCode)
        if err != nil </span><span class="cov1" title="1">{
                if err == gorm.ErrRecordNotFound </span><span class="cov1" title="1">{
                        c.JSON(makeHttpErrorResponse(http.StatusNotFound, fmt.Sprintf("error get transaction: %v", err.Error())))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(makeHttpErrorResponse(http.StatusInternalServerError, fmt.Sprintf("error get transaction: %v", err.Error())))
                return</span>
        }

        <span class="cov1" title="1">c.JSON(makeHttpResponse(http.StatusOK, transactionDto))</span>
}

// ListTransactions godoc
// @summary List Transaction
// @description Get list of transactions
// @tags transasctions
// @id ListTransactions
// @produce json
// @param page query int false "number of page"
// @param size query int false "size of data per page"
// @response 200 {object} handler.ResultResponse[pagination.PaginateResult[entity.TransactionDto]] "OK"
// @response 500 {object} handler.ErrorResponse "Internal Server Error"
// @router /transactions [get]
func (handler *TransactionHandler) ListTransactions(c *gin.Context) <span class="cov0" title="0">{
        var paginateOptions pagination.PaginateOptions
        if err := c.ShouldBindQuery(&amp;paginateOptions); err != nil </span><span class="cov0" title="0">{
                c.JSON(makeHttpErrorResponse(http.StatusInternalServerError, fmt.Sprintf("error get transaction: %v", err.Error())))
                return
        }</span>

        <span class="cov0" title="0">transactions := handler.transactionUseCase.ListTransactions(paginateOptions)
        c.JSON(makeHttpResponse(http.StatusOK, transactions))</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package handler

import (
        "errors"
        "fund-o/api-server/internal/entity"
        "fund-o/api-server/internal/http/middleware"
        "fund-o/api-server/internal/usecase"
        "fund-o/api-server/pkg/apperrors"
        "fund-o/api-server/pkg/token"
        "net/http"

        "github.com/gin-gonic/gin"
)

type UserHandlerOptions struct {
        usecase.UserUseCase
}

type UserHandler struct {
        userUseCase usecase.UserUseCase
}

func NewUserHandler(options *UserHandlerOptions) *UserHandler <span class="cov1" title="1">{
        return &amp;UserHandler{
                userUseCase: options.UserUseCase,
        }
}</span>

// GetMe godoc
// @summary Get current user
// @description Get current user by validating authorization token
// @tags users
// @id GetMe
// @produce json
// @security ApiKeyAuth
// @response 200 {object} handler.ResultResponse[entity.UserDto] "OK"
// @response 401 {object} handler.ErrorResponse "Unauthorized"
// @response 500 {object} handler.ErrorResponse "Internal Server Error"
// @router /users/me [get]
func (h *UserHandler) GetMe(c *gin.Context) <span class="cov10" title="4">{
        payload := c.MustGet(middleware.AuthorizationPayloadKey).(*token.Payload)
        user, err := h.userUseCase.GetUserById(payload.UserID)
        if err != nil </span><span class="cov8" title="3">{
                if errors.Is(err, apperrors.ErrInvalidUserID) </span><span class="cov1" title="1">{
                        c.JSON(makeHttpErrorResponse(http.StatusBadRequest, err.Error()))
                        return
                }</span>

                <span class="cov5" title="2">if errors.Is(err, apperrors.ErrUserNotFound) </span><span class="cov1" title="1">{
                        c.JSON(makeHttpErrorResponse(http.StatusNotFound, err.Error()))
                        return
                }</span>

                <span class="cov1" title="1">c.JSON(makeHttpErrorResponse(http.StatusInternalServerError, err.Error()))
                return</span>
        }

        <span class="cov1" title="1">c.JSON(makeHttpResponse(http.StatusOK, user))</span>
}

// UpdateUser godoc
// @summary Update user
// @description Update user by id
// @tags users
// @id UpdateUser
// @accept multipart/form-data
// @produce json
// @security ApiKeyAuth
// @param id path string true "User ID"
// @param image formData file true "User profile image"
// @response 200 {object} handler.ResultResponse[entity.UserDto] "OK"
// @response 400 {object} handler.ErrorResponse "Bad Request"
// @response 401 {object} handler.ErrorResponse "Unauthorized"
// @response 500 {object} handler.ErrorResponse "Internal Server Error"
// @router /users/{id} [patch]
func (h *UserHandler) UpdateUser(c *gin.Context) <span class="cov8" title="3">{
        id := c.Param("id")
        userID := c.MustGet(middleware.AuthorizationPayloadKey).(*token.Payload).UserID

        if id != userID </span><span class="cov1" title="1">{
                err := errors.New("unauthorized: user can only update their own profile")
                c.JSON(makeHttpErrorResponse(http.StatusUnauthorized, err.Error()))
                return
        }</span>

        <span class="cov5" title="2">var payload entity.UserUpdatePayload
        if err := c.ShouldBind(&amp;payload); err != nil </span><span class="cov0" title="0">{
                c.JSON(makeHttpErrorResponse(http.StatusBadRequest, err.Error()))
                return
        }</span>

        <span class="cov5" title="2">user, err := h.userUseCase.UpdateUserByID(id, &amp;payload)
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(makeHttpErrorResponse(http.StatusInternalServerError, err.Error()))
                return
        }</span>

        <span class="cov1" title="1">c.JSON(makeHttpResponse(http.StatusOK, user))</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package middleware

import (
        "errors"
        "fmt"
        "fund-o/api-server/pkg/token"
        "net/http"
        "strings"

        "github.com/gin-gonic/gin"
)

const (
        AuthorizationHeaderKey  = "authorization"
        AuthorizationTypeBearer = "bearer"
        AuthorizationPayloadKey = "authorization_payload"
)

func AuthMiddleware(tokenMaker token.Maker) gin.HandlerFunc <span class="cov10" title="5">{
        return func(c *gin.Context) </span><span class="cov10" title="5">{
                payload, err := parseQueryToken(c, tokenMaker)
                if err == nil </span><span class="cov0" title="0">{
                        c.Set(AuthorizationPayloadKey, payload)
                        c.Next()
                        return
                }</span>

                <span class="cov10" title="5">authorizationHeader := c.GetHeader(AuthorizationHeaderKey)
                if len(authorizationHeader) == 0 </span><span class="cov1" title="1">{
                        err := errors.New("authorization header is not provided")
                        c.AbortWithStatusJSON(http.StatusUnauthorized, errorResponse(err))
                        return
                }</span>

                <span class="cov8" title="4">fields := strings.Fields(authorizationHeader)
                if len(fields) &lt; 2 </span><span class="cov1" title="1">{
                        err := errors.New("invalid authorization header format")
                        c.AbortWithStatusJSON(http.StatusUnauthorized, errorResponse(err))
                        return
                }</span>

                <span class="cov7" title="3">authorizationType := strings.ToLower(fields[0])
                if authorizationType != AuthorizationTypeBearer </span><span class="cov1" title="1">{
                        err := fmt.Errorf("unsupported authorization type %s", authorizationType)
                        c.AbortWithStatusJSON(http.StatusUnauthorized, errorResponse(err))
                        return
                }</span>

                <span class="cov4" title="2">accessToken := fields[1]
                payload, err = tokenMaker.VerifyToken(accessToken)
                if err != nil </span><span class="cov1" title="1">{
                        c.AbortWithStatusJSON(http.StatusUnauthorized, errorResponse(err))
                        return
                }</span>

                <span class="cov1" title="1">c.Set(AuthorizationPayloadKey, payload)
                c.Next()</span>
        }
}

func parseQueryToken(c *gin.Context, tokenMaker token.Maker) (*token.Payload, error) <span class="cov10" title="5">{
        accessToken := c.Query("token")
        if len(accessToken) == 0 </span><span class="cov10" title="5">{
                return nil, errors.New("access token is not provided")
        }</span>

        <span class="cov0" title="0">payload, err := tokenMaker.VerifyToken(accessToken)
        return payload, err</span>
}

func errorResponse(err error) gin.H <span class="cov8" title="4">{
        return gin.H{
                "status":      http.StatusText(http.StatusUnauthorized),
                "status_code": http.StatusUnauthorized,
                "error":       err.Error(),
        }
}</span>
</pre>
		
		<pre class="file" id="file44" style="display: none">package middleware

import (
        "strings"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/rs/zerolog/log"
)

func RequestLogger() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                ip := c.ClientIP()
                remoteArress := strings.Split(c.Request.RemoteAddr, ":")

                log.Info().
                        Str("method", c.Request.Method).
                        Str("url", c.Request.URL.Path).
                        Str("hostname", c.Request.Host).
                        Str("ip", ip).
                        Str("remote_address", remoteArress[0]).
                        Str("remote_port", remoteArress[1]).
                        Msg("incoming request")
                c.Next()
        }</span>
}

func ResponseLogger() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                now := time.Now()

                c.Next()

                log.Info().
                        Int("status_code", c.Writer.Status()).
                        Dur("response_time", time.Since(now)).
                        Msg("request completed")
        }</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package usecase

import (
        "fund-o/api-server/internal/datasource/repository"
        "fund-o/api-server/internal/entity"
        "fund-o/api-server/pkg/apperrors"
        "github.com/google/uuid"
)

type ChannelUsecase interface {
        CreateChannel(payload *entity.ChannelCreatePayload) (*entity.ChannelDto, error)
        GetExistingChannel(userID string, channelID string) (*entity.ChannelDto, error)
        GetChannelByUserID(userID string) ([]entity.ChannelDto, error)
}

type channelUsecase struct {
        channelRepository repository.ChannelRepository
        userRepository    repository.UserRepository
}

type ChannelUsecaseOptions struct {
        repository.ChannelRepository
}

func NewChannelUsecase(options *ChannelUsecaseOptions) ChannelUsecase <span class="cov0" title="0">{
        return &amp;channelUsecase{
                channelRepository: options.ChannelRepository,
        }
}</span>

func (u *channelUsecase) CreateChannel(payload *entity.ChannelCreatePayload) (*entity.ChannelDto, error) <span class="cov0" title="0">{
        if len(payload.Members) != 2 </span><span class="cov0" title="0">{
                return nil, apperrors.ErrInvalidMemberChannelLength
        }</span>

        <span class="cov0" title="0">members := []entity.User{
                {
                        Base: entity.Base{ID: uuid.MustParse(payload.Members[0])},
                },
                {
                        Base: entity.Base{ID: uuid.MustParse(payload.Members[1])},
                },
        }

        channel := entity.Channel{
                Name:     payload.Name,
                Members:  members,
                Messages: []entity.Message{},
        }

        newChannel, err := u.channelRepository.Create(&amp;channel)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return newChannel.ToChannelDto(), nil</span>
}

func (u *channelUsecase) GetExistingChannel(userID string, channelID string) (*entity.ChannelDto, error) <span class="cov0" title="0">{
        channel, err := u.channelRepository.GetExistingChannel(userID, channelID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if channel.ID == uuid.Nil </span><span class="cov0" title="0">{
                return nil, apperrors.ErrChannelNotFound
        }</span>

        <span class="cov0" title="0">return channel.ToChannelDto(), nil</span>
}

func (u *channelUsecase) GetChannelByUserID(userID string) ([]entity.ChannelDto, error) <span class="cov0" title="0">{
        channels, err := u.channelRepository.GetByUserID(userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var channelDtos []entity.ChannelDto
        for _, c := range channels </span><span class="cov0" title="0">{
                channelDtos = append(channelDtos, *c.ToChannelDto())
        }</span>

        <span class="cov0" title="0">return channelDtos, nil</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package usecase

import (
        "fund-o/api-server/internal/datasource/repository"
        "fund-o/api-server/internal/entity"
        "fund-o/api-server/pkg/apperrors"
        "fund-o/api-server/pkg/pagination"
        "fund-o/api-server/pkg/uploader"
        "github.com/google/uuid"
        "mime/multipart"
        "net/http"
)

type ForumUseCase interface {
        ListForums(paginateOptions pagination.PaginateOptions) pagination.PaginateResult[entity.PostDto]
        CreatePost(payload *entity.PostCreatePayload) (*entity.PostDto, error)
        GetPostByID(id string) (*entity.PostDto, error)
        CreateCommentByForumID(forumID string, comment *entity.CommentCreatePayload) (*entity.CommentDto, error)
        CreateReplyByCommentID(commentID string, payload *entity.ReplyCreatePayload) (*entity.ReplyDto, error)
        UploadPostImage(file *multipart.FileHeader) (string, apperrors.Error)
}

type forumUseCase struct {
        forumRepository repository.ForumRepository
        imageUploader   uploader.ImageUploader
}

type ForumUseCaseOptions struct {
        repository.ForumRepository
        uploader.ImageUploader
}

func NewForumUseCase(options *ForumUseCaseOptions) ForumUseCase <span class="cov1" title="1">{
        return &amp;forumUseCase{
                forumRepository: options.ForumRepository,
                imageUploader:   options.ImageUploader,
        }
}</span>

func (uc *forumUseCase) ListForums(paginateOptions pagination.PaginateOptions) pagination.PaginateResult[entity.PostDto] <span class="cov3" title="3">{
        result := pagination.MakePaginateResult(pagination.MakePaginateContextParameters[entity.PostDto]{
                PaginateOptions: paginateOptions,
                CountDocuments: func() int64 </span><span class="cov3" title="3">{
                        return uc.forumRepository.CountPost()
                }</span>,
                FindDocuments: func(findOptions pagination.PaginateFindOptions) []entity.PostDto <span class="cov3" title="3">{
                        documents := uc.forumRepository.ListPosts(findOptions)

                        forumDtos := make([]entity.PostDto, 0, len(documents))
                        for _, document := range documents </span><span class="cov10" title="45">{
                                forumDtos = append(forumDtos, *document.ToPostDto())
                        }</span>

                        <span class="cov3" title="3">return forumDtos</span>
                },
        })

        <span class="cov3" title="3">return result</span>
}

func (uc *forumUseCase) CreatePost(payload *entity.PostCreatePayload) (*entity.PostDto, error) <span class="cov2" title="2">{
        forum, err := uc.forumRepository.CreatePost(&amp;entity.Post{
                Title:       payload.Title,
                Description: payload.Description,
                Content:     payload.Content,
                AuthorID:    uuid.MustParse(payload.AuthorID),
                ProjectID:   uuid.MustParse(payload.ProjectID),
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return forum.ToPostDto(), nil</span>
}

func (uc *forumUseCase) GetPostByID(id string) (*entity.PostDto, error) <span class="cov2" title="2">{
        forum, err := uc.forumRepository.FindPostByID(uuid.MustParse(id))
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return forum.ToPostDto(), nil</span>
}

func (uc *forumUseCase) CreateCommentByForumID(postID string, payload *entity.CommentCreatePayload) (*entity.CommentDto, error) <span class="cov0" title="0">{
        comment, err := uc.forumRepository.CreateComment(&amp;entity.Comment{
                Content:  payload.Content,
                AuthorID: uuid.MustParse(payload.AuthorID),
                PostID:   uuid.MustParse(postID),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return comment.ToCommentDto(), nil</span>
}

func (uc *forumUseCase) CreateReplyByCommentID(commentID string, payload *entity.ReplyCreatePayload) (*entity.ReplyDto, error) <span class="cov0" title="0">{
        reply, err := uc.forumRepository.CreateReply(&amp;entity.Reply{
                Content:   payload.Content,
                AuthorID:  uuid.MustParse(payload.AuthorID),
                CommentID: uuid.MustParse(commentID),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return reply.ToReplyDto(), nil</span>
}

func (uc *forumUseCase) UploadPostImage(file *multipart.FileHeader) (string, apperrors.Error) <span class="cov0" title="0">{
        image, err := uc.imageUploader.Upload(uploader.PostImageFolder, file)
        if err != nil </span><span class="cov0" title="0">{
                return "", apperrors.New(http.StatusInternalServerError, "Failed to upload post image")
        }</span>

        <span class="cov0" title="0">return image, nil</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package usecase

import (
        "fund-o/api-server/internal/datasource/repository"
        "fund-o/api-server/internal/entity"
        "fund-o/api-server/pkg/uploader"
        "github.com/google/uuid"
)

type MessageUsecase interface {
        CreateChannelMessage(channelID uuid.UUID, payload *entity.MessageCreatePayload) (*entity.MessageDto, error)
}

type messageUsecase struct {
        messageRepository repository.MessageRepository
        imageUploader     uploader.ImageUploader
}

type MessageUsecaseOptions struct {
        repository.MessageRepository
        uploader.ImageUploader
}

func NewMessageUsecase(options *MessageUsecaseOptions) MessageUsecase <span class="cov0" title="0">{
        return &amp;messageUsecase{
                messageRepository: options.MessageRepository,
                imageUploader:     options.ImageUploader,
        }
}</span>

func (u *messageUsecase) CreateChannelMessage(channelID uuid.UUID, payload *entity.MessageCreatePayload) (*entity.MessageDto, error) <span class="cov0" title="0">{
        var attachment *string
        if payload.Attachment != nil </span><span class="cov0" title="0">{
                attachmentURL, err := u.imageUploader.Upload(uploader.PostImageFolder, payload.Attachment)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">attachment = &amp;attachmentURL</span>
        }

        <span class="cov0" title="0">message := entity.Message{
                Text:       payload.Text,
                Attachment: attachment,
                ChannelID:  channelID,
                AuthorID:   payload.AuthorID,
        }

        newMessage, err := u.messageRepository.Create(&amp;message)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return newMessage.ToMessageDto(), nil</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package usecase

import (
        "fund-o/api-server/internal/datasource/repository"
        "fund-o/api-server/internal/entity"
)

type ProjectCategoryUseCase interface {
        ListProjectCategories() ([]entity.ProjectCategoryDto, error)
}

type projectCategoryUseCase struct {
        projectCategoryRepository repository.ProjectCategoryRepository
}

type ProjectCategoryUseCaseOptions struct {
        repository.ProjectCategoryRepository
}

func NewProjectCategoryUseCase(options *ProjectCategoryUseCaseOptions) ProjectCategoryUseCase <span class="cov0" title="0">{
        return &amp;projectCategoryUseCase{
                projectCategoryRepository: options.ProjectCategoryRepository,
        }
}</span>

func (uc *projectCategoryUseCase) ListProjectCategories() ([]entity.ProjectCategoryDto, error) <span class="cov0" title="0">{
        categories, err := uc.projectCategoryRepository.FindAll()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">categoryDtos := make([]entity.ProjectCategoryDto, 0, len(categories))
        for _, category := range categories </span><span class="cov0" title="0">{
                categoryDtos = append(categoryDtos, *category.ToProjectCategoryDto())
        }</span>

        <span class="cov0" title="0">return categoryDtos, nil</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package usecase

import (
        "errors"
        "fund-o/api-server/internal/datasource/repository"
        "fund-o/api-server/internal/entity"
        "fund-o/api-server/pkg/apperrors"
        "fund-o/api-server/pkg/pagination"
        "fund-o/api-server/pkg/uploader"
        "github.com/shopspring/decimal"
        "gorm.io/gorm"
        "net/http"
        "time"

        "github.com/google/uuid"
)

type ProjectUseCase interface {
        ListProjects(params entity.ProjectListParams) pagination.PaginateResult[entity.ProjectDto]
        CreateProject(project *entity.ProjectCreatePayload) (*entity.ProjectDto, error)
        GetProjectByID(projectID string) (*entity.ProjectDto, apperrors.Error)
        GetProjectsByOwnerID(requestOwnerID string) ([]entity.ProjectDto, error)
        GetRecommendationProjects() ([]entity.ProjectDto, error)
        CreateProjectRating(rating *entity.ProjectRatingCreatePayload) error
        IsRatedProject(userID string, projectID string) (bool, error)
        CreateBackProject(userID string, payload *entity.ProjectBackerCreatePayload) error
        GetBackedProjects(userID string) ([]entity.ListBackedProjectResponse, error)
}

type projectUseCase struct {
        projectRepository repository.ProjectRepository
        imageUploader     uploader.ImageUploader
}

type ProjectUseCaseOptions struct {
        repository.ProjectRepository
        uploader.ImageUploader
}

func NewProjectUseCase(options *ProjectUseCaseOptions) ProjectUseCase <span class="cov0" title="0">{
        return &amp;projectUseCase{
                projectRepository: options.ProjectRepository,
                imageUploader:     options.ImageUploader,
        }
}</span>

func (uc *projectUseCase) ListProjects(params entity.ProjectListParams) pagination.PaginateResult[entity.ProjectDto] <span class="cov0" title="0">{
        result := pagination.MakePaginateResult(pagination.MakePaginateContextParameters[entity.ProjectDto]{
                PaginateOptions: params.PaginateOptions,
                CountDocuments: func() int64 </span><span class="cov0" title="0">{
                        return uc.projectRepository.Count()
                }</span>,
                FindDocuments: func(findOptions pagination.PaginateFindOptions) []entity.ProjectDto <span class="cov0" title="0">{
                        parsedCategoryId, err := uuid.Parse(params.CategoryID)
                        if err != nil </span><span class="cov0" title="0">{
                                parsedCategoryId = uuid.Nil
                        }</span>

                        <span class="cov0" title="0">parsedSubCategoryId, err := uuid.Parse(params.SubCategoryID)
                        if err != nil </span><span class="cov0" title="0">{
                                parsedSubCategoryId = uuid.Nil
                        }</span>

                        <span class="cov0" title="0">documents := uc.projectRepository.FindAll(findOptions, entity.ProjectListOptions{
                                Query:         params.Query,
                                CategoryID:    parsedCategoryId,
                                SubCategoryID: parsedSubCategoryId,
                        })

                        projectDtos := make([]entity.ProjectDto, 0, len(documents))
                        for _, document := range documents </span><span class="cov0" title="0">{
                                projectDtos = append(projectDtos, *document.ToProjectDto())
                        }</span>

                        <span class="cov0" title="0">return projectDtos</span>
                },
        })

        <span class="cov0" title="0">return result</span>
}

func (uc *projectUseCase) CreateProject(project *entity.ProjectCreatePayload) (*entity.ProjectDto, error) <span class="cov0" title="0">{
        ownerID := uuid.MustParse(project.OwnerID)

        endDate, err := time.Parse(time.RFC3339, project.EndDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">image, err := uc.imageUploader.Upload(uploader.ProjectImageFolder, project.Image)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">payload := &amp;entity.Project{
                ProjectContractID: project.ProjectContractID,
                Title:             project.Title,
                SubTitle:          project.SubTitle,
                Description:       project.Description,
                CategoryID:        uuid.MustParse(project.CategoryID),
                SubCategoryID:     uuid.MustParse(project.SubCategoryID),
                Location:          project.Location,
                Image:             image,
                StartDate:         time.Now(),
                EndDate:           endDate,
                OwnerID:           ownerID,
        }
        newProject, err := uc.projectRepository.Create(payload)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return newProject.ToProjectDto(), nil</span>
}

func (uc *projectUseCase) GetProjectByID(projectID string) (*entity.ProjectDto, apperrors.Error) <span class="cov0" title="0">{
        projectUUID, err := uuid.Parse(projectID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperrors.New(http.StatusBadRequest, "Invalid project ID")
        }</span>

        <span class="cov0" title="0">project, err := uc.projectRepository.FindByID(projectUUID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, apperrors.New(http.StatusNotFound, "Project not found")
                }</span>

                <span class="cov0" title="0">return nil, apperrors.New(http.StatusInternalServerError, "Failed to get project")</span>
        }

        <span class="cov0" title="0">return project.ToProjectDto(), nil</span>
}

func (uc *projectUseCase) GetProjectsByOwnerID(requestOwnerID string) ([]entity.ProjectDto, error) <span class="cov0" title="0">{
        ownerID, err := uuid.Parse(requestOwnerID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperrors.ErrInvalidUserID
        }</span>

        <span class="cov0" title="0">projects, err := uc.projectRepository.FindAllByOwnerID(ownerID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">projectDtos := make([]entity.ProjectDto, 0, len(projects))
        for _, project := range projects </span><span class="cov0" title="0">{
                projectDtos = append(projectDtos, *project.ToProjectDto())
        }</span>

        <span class="cov0" title="0">return projectDtos, nil</span>
}

func (uc *projectUseCase) GetRecommendationProjects() ([]entity.ProjectDto, error) <span class="cov0" title="0">{
        projects, err := uc.projectRepository.FindRecommendation(3)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">projectDtos := make([]entity.ProjectDto, 0, len(projects))
        for _, project := range projects </span><span class="cov0" title="0">{
                projectDtos = append(projectDtos, *project.ToProjectDto())
        }</span>

        <span class="cov0" title="0">return projectDtos, nil</span>
}

func (uc *projectUseCase) CreateProjectRating(rating *entity.ProjectRatingCreatePayload) error <span class="cov0" title="0">{
        projectID, err := uuid.Parse(rating.ProjectID)
        if err != nil </span><span class="cov0" title="0">{
                return apperrors.ErrInvalidProjectID
        }</span>

        <span class="cov0" title="0">userID, err := uuid.Parse(rating.UserID)
        if err != nil </span><span class="cov0" title="0">{
                return apperrors.ErrInvalidUserID
        }</span>

        <span class="cov0" title="0">pr, prErr := uc.projectRepository.FindProjectRating(userID, projectID)
        if prErr != nil &amp;&amp; !errors.Is(prErr, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                return prErr
        }</span>

        <span class="cov0" title="0">if pr.ID != uuid.Nil </span><span class="cov0" title="0">{
                return apperrors.ErrAlreadyRatedProject
        }</span>

        <span class="cov0" title="0">_, err = uc.projectRepository.CreateProjectRating(&amp;entity.ProjectRating{
                Rating:    rating.Rating,
                ProjectID: projectID,
                UserID:    userID,
        })
        return err</span>
}
func (uc *projectUseCase) IsRatedProject(userID string, projectID string) (bool, error) <span class="cov0" title="0">{
        userIDParsed := uuid.MustParse(userID)
        projectIDParsed := uuid.MustParse(projectID)
        pr, err := uc.projectRepository.FindProjectRating(userIDParsed, projectIDParsed)
        if err != nil &amp;&amp; !errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">if pr.ID != uuid.Nil </span><span class="cov0" title="0">{
                return true, nil
        }</span>

        <span class="cov0" title="0">return false, nil</span>
}

func (uc *projectUseCase) CreateBackProject(userID string, payload *entity.ProjectBackerCreatePayload) error <span class="cov0" title="0">{
        parsedUserID, err := uuid.Parse(userID)
        if err != nil </span><span class="cov0" title="0">{
                return apperrors.ErrInvalidUserID
        }</span>

        <span class="cov0" title="0">parsedProjectID, err := uuid.Parse(payload.ProjectID)
        if err != nil </span><span class="cov0" title="0">{
                return apperrors.ErrInvalidProjectID
        }</span>

        <span class="cov0" title="0">_, err = uc.projectRepository.CreateProjectBacker(&amp;entity.ProjectBacker{
                ProjectID: parsedProjectID,
                UserID:    parsedUserID,
                Amount:    decimal.NewFromFloat(payload.Amount),
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (uc *projectUseCase) GetBackedProjects(userID string) ([]entity.ListBackedProjectResponse, error) <span class="cov0" title="0">{
        projectFundings, err := uc.projectRepository.FindBackProjectsByUserID(userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">backedProjects := make([]entity.ListBackedProjectResponse, 0, len(projectFundings))
        for _, projectFunding := range projectFundings </span><span class="cov0" title="0">{
                project, err := uc.projectRepository.FindByID(projectFunding.ProjectID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">backedProjects = append(backedProjects, entity.ListBackedProjectResponse{
                        Project:    *project.ToProjectDto(),
                        FundAmount: projectFunding.TotalFunds,
                })</span>

        }

        <span class="cov0" title="0">return backedProjects, nil</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package usecase

import (
        "fund-o/api-server/internal/datasource/repository"
        "fund-o/api-server/internal/entity"

        "github.com/google/uuid"
)

type SessionUseCase interface {
        CreateSession(payload *entity.SessionCreatePayload) (*entity.SessionDto, error)
        GetSessionByID(sessionID uuid.UUID) (*entity.SessionDto, error)
}

type sessionUseCase struct {
        sessionRepository repository.SessionRepository
}

type SessionUseCaseOptions struct {
        repository.SessionRepository
}

func NewSessionUseCase(options *SessionUseCaseOptions) SessionUseCase <span class="cov10" title="2">{
        return &amp;sessionUseCase{
                sessionRepository: options.SessionRepository,
        }
}</span>

func (uc *sessionUseCase) CreateSession(payload *entity.SessionCreatePayload) (*entity.SessionDto, error) <span class="cov10" title="2">{
        session := entity.Session{
                ID:           payload.ID,
                UserID:       uuid.MustParse(payload.UserID),
                RefreshToken: payload.RefreshToken,
                UserAgent:    payload.UserAgent,
                ClientIP:     payload.ClientIP,
                ExpiredAt:    payload.ExpiredAt,
        }

        newSession, err := uc.sessionRepository.Create(&amp;session)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov10" title="2">return newSession.ToSessionDto(), nil</span>
}

func (uc *sessionUseCase) GetSessionByID(sessionID uuid.UUID) (*entity.SessionDto, error) <span class="cov0" title="0">{
        session, err := uc.sessionRepository.FindByID(sessionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return session.ToSessionDto(), nil</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package usecase

import (
        "fund-o/api-server/internal/datasource/repository"
        "fund-o/api-server/internal/entity"
        "fund-o/api-server/pkg/pagination"
)

type TransactionUseCase interface {
        CreateTransaction(transaction *entity.TransactionCreatePayload) (*entity.TransactionDto, error)
        GetTransactionByRefCode(refCode string) (*entity.TransactionDto, error)
        ListTransactions(paginateOptions pagination.PaginateOptions) pagination.PaginateResult[entity.TransactionDto]
}

type transactionRepository struct {
        transactionRepository repository.TransactionRepository
}

type TransactionUseCaseOptions struct {
        TransactionRepository repository.TransactionRepository
}

func NewTransactionUseCase(options *TransactionUseCaseOptions) TransactionUseCase <span class="cov10" title="2">{
        return &amp;transactionRepository{
                transactionRepository: options.TransactionRepository,
        }
}</span>

func (uc *transactionRepository) CreateTransaction(transaction *entity.TransactionCreatePayload) (*entity.TransactionDto, error) <span class="cov1" title="1">{
        newTransaction := &amp;entity.Transaction{
                RefCode: transaction.RefCode,
        }
        newTransaction, err := uc.transactionRepository.Create(newTransaction)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return newTransaction.ToTransactionDto(), nil</span>
}

func (uc *transactionRepository) GetTransactionByRefCode(refCode string) (*entity.TransactionDto, error) <span class="cov10" title="2">{
        existingTransaction, err := uc.transactionRepository.FindByRefCode(refCode)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return existingTransaction.ToTransactionDto(), nil</span>
}

func (uc *transactionRepository) ListTransactions(paginateOptions pagination.PaginateOptions) pagination.PaginateResult[entity.TransactionDto] <span class="cov0" title="0">{
        result := pagination.MakePaginateResult(pagination.MakePaginateContextParameters[entity.TransactionDto]{
                PaginateOptions: paginateOptions,
                CountDocuments: func() int64 </span><span class="cov0" title="0">{
                        return uc.transactionRepository.Count()
                }</span>,
                FindDocuments: func(findOptions pagination.PaginateFindOptions) []entity.TransactionDto <span class="cov0" title="0">{
                        documents := uc.transactionRepository.List(findOptions)

                        transactionDtos := make([]entity.TransactionDto, 0, len(documents))
                        for _, document := range documents </span><span class="cov0" title="0">{
                                transactionDtos = append(transactionDtos, *document.ToTransactionDto())
                        }</span>

                        <span class="cov0" title="0">return transactionDtos</span>
                },
        })

        <span class="cov0" title="0">return result</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package usecase

import (
        "errors"
        "fund-o/api-server/internal/datasource/repository"
        "fund-o/api-server/internal/entity"
        "fund-o/api-server/pkg/apperrors"
        "fund-o/api-server/pkg/password"
        "fund-o/api-server/pkg/uploader"
        "github.com/google/uuid"
        "gorm.io/gorm"
)

type UserUseCase interface {
        CreateUser(user *entity.User) (*entity.UserDto, error)
        AuthenticateUser(payload *entity.UserLoginPayload) (*entity.UserDto, error)
        GetUserById(id string) (*entity.UserDto, error)
        GetUserByEmail(email string) (*entity.UserDto, error)
        UpdateUserByID(id string, user *entity.UserUpdatePayload) (*entity.UserDto, error)
}

type userUseCase struct {
        userRepository repository.UserRepository
        imageUploader  uploader.ImageUploader
}

type UserUseCaseOptions struct {
        repository.UserRepository
        uploader.ImageUploader
}

func NewUserUseCase(options *UserUseCaseOptions) UserUseCase <span class="cov8" title="3">{
        return &amp;userUseCase{
                userRepository: options.UserRepository,
                imageUploader:  options.ImageUploader,
        }
}</span>

func (uc *userUseCase) CreateUser(user *entity.User) (*entity.UserDto, error) <span class="cov5" title="2">{
        newUser, err := uc.userRepository.Create(user)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return newUser.ToUserDto(), nil</span>
}

func (uc *userUseCase) AuthenticateUser(payload *entity.UserLoginPayload) (*entity.UserDto, error) <span class="cov5" title="2">{
        user, err := uc.userRepository.FindByEmail(payload.Email)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if err := password.CheckPassword(payload.Password, user.HashedPassword); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return user.ToUserDto(), nil</span>
}

func (uc *userUseCase) GetUserById(id string) (*entity.UserDto, error) <span class="cov10" title="4">{
        userID, err := uuid.Parse(id)
        if err != nil </span><span class="cov1" title="1">{
                return nil, apperrors.ErrInvalidUserID
        }</span>

        <span class="cov8" title="3">user, err := uc.userRepository.FindById(userID)
        if err != nil </span><span class="cov5" title="2">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov1" title="1">{
                        return nil, apperrors.ErrUserNotFound
                }</span>

                <span class="cov1" title="1">return nil, err</span>
        }

        <span class="cov1" title="1">return user.ToUserDto(), nil</span>
}

func (uc *userUseCase) GetUserByEmail(email string) (*entity.UserDto, error) <span class="cov0" title="0">{
        user, err := uc.userRepository.FindByEmail(email)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return user.ToUserDto(), nil</span>
}

func (uc *userUseCase) UpdateUserByID(id string, user *entity.UserUpdatePayload) (*entity.UserDto, error) <span class="cov5" title="2">{
        userID := uuid.MustParse(id)

        var profileImage string
        if user.ProfileImage != nil </span><span class="cov0" title="0">{
                imageSource, err := uc.imageUploader.Upload(uploader.ProfileImageFolder, user.ProfileImage)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">profileImage = imageSource</span>
        }

        <span class="cov5" title="2">payload := entity.User{
                Email:             user.Email,
                DisplayName:       user.DisplayName,
                ProfileImage:      profileImage,
                MetaMaskAccountID: user.MetamaskAccountID,
                IsEmailVerified:   user.IsEmailVerified,
        }

        updatedUser, err := uc.userRepository.UpdateByID(userID, &amp;payload)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return updatedUser.ToUserDto(), nil</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package usecase

import (
        "errors"
        "fund-o/api-server/internal/datasource/repository"
        "fund-o/api-server/internal/entity"
        "time"
)

type VerifyEmailUseCase interface {
        CreateVerifyEmail(verifyEmail *entity.VerifyEmailCreatePayload) (*entity.VerifyEmailDto, error)
        VerifyEmail(payload *entity.VerifyEmailUpdatePayload) (*entity.VerifyEmailDto, error)
}

type verifyEmailUseCase struct {
        verifyEmailRepository repository.VerifyEmailRepository
}

type VerifyEmailUseCaseOptions struct {
        repository.VerifyEmailRepository
}

func NewVerifyEmailUseCase(options *VerifyEmailUseCaseOptions) VerifyEmailUseCase <span class="cov0" title="0">{
        return &amp;verifyEmailUseCase{
                verifyEmailRepository: options.VerifyEmailRepository,
        }
}</span>

func (uc *verifyEmailUseCase) CreateVerifyEmail(verifyEmail *entity.VerifyEmailCreatePayload) (*entity.VerifyEmailDto, error) <span class="cov0" title="0">{
        ve, err := uc.verifyEmailRepository.Create(&amp;entity.VerifyEmail{
                Email:      verifyEmail.Email,
                SecretCode: verifyEmail.SecretCode,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return ve.ToVerifyEmailDto(), nil</span>
}

func (uc *verifyEmailUseCase) VerifyEmail(payload *entity.VerifyEmailUpdatePayload) (*entity.VerifyEmailDto, error) <span class="cov0" title="0">{
        ve, err := uc.verifyEmailRepository.FindByID(payload.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if ve.SecretCode != payload.SecretCode </span><span class="cov0" title="0">{
                return nil, errors.New("invalid secret code")
        }</span>

        <span class="cov0" title="0">if ve.IsUsed </span><span class="cov0" title="0">{
                return nil, errors.New("verify email already used")
        }</span>

        <span class="cov0" title="0">if ve.ExpiredAt.Before(time.Now()) </span><span class="cov0" title="0">{
                return nil, errors.New("verify email already expired")
        }</span>

        <span class="cov0" title="0">ve.IsUsed = true

        ve, err = uc.verifyEmailRepository.UpdateByID(ve.ID.String(), ve)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return ve.ToVerifyEmailDto(), nil</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ./internal/datasource/repository/forum_repository.go

// Package mocks is a generated GoMock package.
package mocks

import (
        entity "fund-o/api-server/internal/entity"
        pagination "fund-o/api-server/pkg/pagination"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        uuid "github.com/google/uuid"
)

// MockForumRepository is a mock of ForumRepository interface.
type MockForumRepository struct {
        ctrl     *gomock.Controller
        recorder *MockForumRepositoryMockRecorder
}

// MockForumRepositoryMockRecorder is the mock recorder for MockForumRepository.
type MockForumRepositoryMockRecorder struct {
        mock *MockForumRepository
}

// NewMockForumRepository creates a new mock instance.
func NewMockForumRepository(ctrl *gomock.Controller) *MockForumRepository <span class="cov1" title="1">{
        mock := &amp;MockForumRepository{ctrl: ctrl}
        mock.recorder = &amp;MockForumRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockForumRepository) EXPECT() *MockForumRepositoryMockRecorder <span class="cov10" title="11">{
        return m.recorder
}</span>

// CountPost mocks base method.
func (m *MockForumRepository) CountPost() int64 <span class="cov5" title="3">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CountPost")
        ret0, _ := ret[0].(int64)
        return ret0
}</span>

// CountPost indicates an expected call of CountPost.
func (mr *MockForumRepositoryMockRecorder) CountPost() *gomock.Call <span class="cov5" title="3">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CountPost", reflect.TypeOf((*MockForumRepository)(nil).CountPost))
}</span>

// CreateComment mocks base method.
func (m *MockForumRepository) CreateComment(comment *entity.Comment) (*entity.Comment, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateComment", comment)
        ret0, _ := ret[0].(*entity.Comment)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateComment indicates an expected call of CreateComment.
func (mr *MockForumRepositoryMockRecorder) CreateComment(comment interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateComment", reflect.TypeOf((*MockForumRepository)(nil).CreateComment), comment)
}</span>

// CreatePost mocks base method.
func (m *MockForumRepository) CreatePost(forum *entity.Post) (*entity.Post, error) <span class="cov3" title="2">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreatePost", forum)
        ret0, _ := ret[0].(*entity.Post)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreatePost indicates an expected call of CreatePost.
func (mr *MockForumRepositoryMockRecorder) CreatePost(forum interface{}) *gomock.Call <span class="cov5" title="3">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreatePost", reflect.TypeOf((*MockForumRepository)(nil).CreatePost), forum)
}</span>

// CreateReply mocks base method.
func (m *MockForumRepository) CreateReply(reply *entity.Reply) (*entity.Reply, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateReply", reply)
        ret0, _ := ret[0].(*entity.Reply)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateReply indicates an expected call of CreateReply.
func (mr *MockForumRepositoryMockRecorder) CreateReply(reply interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateReply", reflect.TypeOf((*MockForumRepository)(nil).CreateReply), reply)
}</span>

// FindAllPostsByAuthorID mocks base method.
func (m *MockForumRepository) FindAllPostsByAuthorID(authorID uuid.UUID) ([]entity.Post, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindAllPostsByAuthorID", authorID)
        ret0, _ := ret[0].([]entity.Post)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// FindAllPostsByAuthorID indicates an expected call of FindAllPostsByAuthorID.
func (mr *MockForumRepositoryMockRecorder) FindAllPostsByAuthorID(authorID interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindAllPostsByAuthorID", reflect.TypeOf((*MockForumRepository)(nil).FindAllPostsByAuthorID), authorID)
}</span>

// FindPostByID mocks base method.
func (m *MockForumRepository) FindPostByID(id uuid.UUID) (*entity.Post, error) <span class="cov3" title="2">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindPostByID", id)
        ret0, _ := ret[0].(*entity.Post)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// FindPostByID indicates an expected call of FindPostByID.
func (mr *MockForumRepositoryMockRecorder) FindPostByID(id interface{}) *gomock.Call <span class="cov3" title="2">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindPostByID", reflect.TypeOf((*MockForumRepository)(nil).FindPostByID), id)
}</span>

// ListPosts mocks base method.
func (m *MockForumRepository) ListPosts(findOptions pagination.PaginateFindOptions) []entity.Post <span class="cov5" title="3">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListPosts", findOptions)
        ret0, _ := ret[0].([]entity.Post)
        return ret0
}</span>

// ListPosts indicates an expected call of ListPosts.
func (mr *MockForumRepositoryMockRecorder) ListPosts(findOptions interface{}) *gomock.Call <span class="cov5" title="3">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListPosts", reflect.TypeOf((*MockForumRepository)(nil).ListPosts), findOptions)
}</span>
</pre>
		
		<pre class="file" id="file55" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ./internal/datasource/repository/session_repository.go

// Package mocks is a generated GoMock package.
package mocks

import (
        entity "fund-o/api-server/internal/entity"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        uuid "github.com/google/uuid"
)

// MockSessionRepository is a mock of SessionRepository interface.
type MockSessionRepository struct {
        ctrl     *gomock.Controller
        recorder *MockSessionRepositoryMockRecorder
}

// MockSessionRepositoryMockRecorder is the mock recorder for MockSessionRepository.
type MockSessionRepositoryMockRecorder struct {
        mock *MockSessionRepository
}

// NewMockSessionRepository creates a new mock instance.
func NewMockSessionRepository(ctrl *gomock.Controller) *MockSessionRepository <span class="cov10" title="2">{
        mock := &amp;MockSessionRepository{ctrl: ctrl}
        mock.recorder = &amp;MockSessionRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSessionRepository) EXPECT() *MockSessionRepositoryMockRecorder <span class="cov10" title="2">{
        return m.recorder
}</span>

// Create mocks base method.
func (m *MockSessionRepository) Create(session *entity.Session) (*entity.Session, error) <span class="cov10" title="2">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Create", session)
        ret0, _ := ret[0].(*entity.Session)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Create indicates an expected call of Create.
func (mr *MockSessionRepositoryMockRecorder) Create(session interface{}) *gomock.Call <span class="cov10" title="2">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockSessionRepository)(nil).Create), session)
}</span>

// FindByID mocks base method.
func (m *MockSessionRepository) FindByID(id uuid.UUID) (*entity.Session, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindByID", id)
        ret0, _ := ret[0].(*entity.Session)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// FindByID indicates an expected call of FindByID.
func (mr *MockSessionRepositoryMockRecorder) FindByID(id interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByID", reflect.TypeOf((*MockSessionRepository)(nil).FindByID), id)
}</span>
</pre>
		
		<pre class="file" id="file56" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ./cmd/worker/distributor.go

// Package mocks is a generated GoMock package.
package mocks

import (
        context "context"
        worker "fund-o/api-server/cmd/worker"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        asynq "github.com/hibiken/asynq"
)

// MockTaskDistributor is a mock of TaskDistributor interface.
type MockTaskDistributor struct {
        ctrl     *gomock.Controller
        recorder *MockTaskDistributorMockRecorder
}

// MockTaskDistributorMockRecorder is the mock recorder for MockTaskDistributor.
type MockTaskDistributorMockRecorder struct {
        mock *MockTaskDistributor
}

// NewMockTaskDistributor creates a new mock instance.
func NewMockTaskDistributor(ctrl *gomock.Controller) *MockTaskDistributor <span class="cov10" title="2">{
        mock := &amp;MockTaskDistributor{ctrl: ctrl}
        mock.recorder = &amp;MockTaskDistributorMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTaskDistributor) EXPECT() *MockTaskDistributorMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// DistributeTaskSendVerifyEmail mocks base method.
func (m *MockTaskDistributor) DistributeTaskSendVerifyEmail(ctx context.Context, payload *worker.PayloadSendVerifyEmail, opts ...asynq.Option) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, payload}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">m.ctrl.Call(m, "DistributeTaskSendVerifyEmail", varargs...)</span>
}

// DistributeTaskSendVerifyEmail indicates an expected call of DistributeTaskSendVerifyEmail.
func (mr *MockTaskDistributorMockRecorder) DistributeTaskSendVerifyEmail(ctx, payload interface{}, opts ...interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, payload}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DistributeTaskSendVerifyEmail", reflect.TypeOf((*MockTaskDistributor)(nil).DistributeTaskSendVerifyEmail), varargs...)
}</span>
</pre>
		
		<pre class="file" id="file57" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ./pkg/uploader/uploader.go

// Package mocks is a generated GoMock package.
package mocks

import (
        multipart "mime/multipart"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockImageUploader is a mock of ImageUploader interface.
type MockImageUploader struct {
        ctrl     *gomock.Controller
        recorder *MockImageUploaderMockRecorder
}

// MockImageUploaderMockRecorder is the mock recorder for MockImageUploader.
type MockImageUploaderMockRecorder struct {
        mock *MockImageUploader
}

// NewMockImageUploader creates a new mock instance.
func NewMockImageUploader(ctrl *gomock.Controller) *MockImageUploader <span class="cov10" title="2">{
        mock := &amp;MockImageUploader{ctrl: ctrl}
        mock.recorder = &amp;MockImageUploaderMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockImageUploader) EXPECT() *MockImageUploaderMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Upload mocks base method.
func (m *MockImageUploader) Upload(folder string, file *multipart.FileHeader) (string, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Upload", folder, file)
        ret0, _ := ret[0].(string)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Upload indicates an expected call of Upload.
func (mr *MockImageUploaderMockRecorder) Upload(folder, file interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Upload", reflect.TypeOf((*MockImageUploader)(nil).Upload), folder, file)
}</span>
</pre>
		
		<pre class="file" id="file58" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ./internal/datasource/repository/user_repository.go

// Package mocks is a generated GoMock package.
package mocks

import (
        entity "fund-o/api-server/internal/entity"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        uuid "github.com/google/uuid"
)

// MockUserRepository is a mock of UserRepository interface.
type MockUserRepository struct {
        ctrl     *gomock.Controller
        recorder *MockUserRepositoryMockRecorder
}

// MockUserRepositoryMockRecorder is the mock recorder for MockUserRepository.
type MockUserRepositoryMockRecorder struct {
        mock *MockUserRepository
}

// NewMockUserRepository creates a new mock instance.
func NewMockUserRepository(ctrl *gomock.Controller) *MockUserRepository <span class="cov5" title="3">{
        mock := &amp;MockUserRepository{ctrl: ctrl}
        mock.recorder = &amp;MockUserRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUserRepository) EXPECT() *MockUserRepositoryMockRecorder <span class="cov10" title="9">{
        return m.recorder
}</span>

// Create mocks base method.
func (m *MockUserRepository) Create(user *entity.User) (*entity.User, error) <span class="cov3" title="2">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Create", user)
        ret0, _ := ret[0].(*entity.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Create indicates an expected call of Create.
func (mr *MockUserRepositoryMockRecorder) Create(user interface{}) *gomock.Call <span class="cov3" title="2">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockUserRepository)(nil).Create), user)
}</span>

// FindByEmail mocks base method.
func (m *MockUserRepository) FindByEmail(email string) (*entity.User, error) <span class="cov3" title="2">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindByEmail", email)
        ret0, _ := ret[0].(*entity.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// FindByEmail indicates an expected call of FindByEmail.
func (mr *MockUserRepositoryMockRecorder) FindByEmail(email interface{}) *gomock.Call <span class="cov3" title="2">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByEmail", reflect.TypeOf((*MockUserRepository)(nil).FindByEmail), email)
}</span>

// FindById mocks base method.
func (m *MockUserRepository) FindById(id uuid.UUID) (*entity.User, error) <span class="cov5" title="3">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindById", id)
        ret0, _ := ret[0].(*entity.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// FindById indicates an expected call of FindById.
func (mr *MockUserRepositoryMockRecorder) FindById(id interface{}) *gomock.Call <span class="cov5" title="3">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindById", reflect.TypeOf((*MockUserRepository)(nil).FindById), id)
}</span>

// UpdateByID mocks base method.
func (m *MockUserRepository) UpdateByID(id uuid.UUID, user *entity.User) (*entity.User, error) <span class="cov3" title="2">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateByID", id, user)
        ret0, _ := ret[0].(*entity.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpdateByID indicates an expected call of UpdateByID.
func (mr *MockUserRepositoryMockRecorder) UpdateByID(id, user interface{}) *gomock.Call <span class="cov3" title="2">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateByID", reflect.TypeOf((*MockUserRepository)(nil).UpdateByID), id, user)
}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">package apperrors

type appError struct {
        Code    int
        Message string
}

type Error interface {
        Status() int
        Error() string
}

func New(code int, message string) Error <span class="cov0" title="0">{
        return &amp;appError{
                Code:    code,
                Message: message,
        }
}</span>

func (e *appError) Status() int <span class="cov0" title="0">{
        return e.Code
}</span>

func (e *appError) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>
</pre>
		
		<pre class="file" id="file60" style="display: none">package helper

import (
        "strings"
)

func ParseString[T any](mapString map[string]T, str string) (T, bool) <span class="cov8" title="1">{
        c, ok := mapString[strings.ToLower(str)]
        return c, ok
}</span>
</pre>
		
		<pre class="file" id="file61" style="display: none">package logger

import (
        "os"
        "time"

        "github.com/rs/zerolog"
        "github.com/rs/zerolog/log"
)

type LoggerConfig struct {
        Env string
}

func InitLogger() <span class="cov0" title="0">{
        consoleWriter := zerolog.ConsoleWriter{
                Out:        os.Stderr,
                TimeFormat: time.RFC3339,
        }

        log.Logger = log.Output(consoleWriter)
}</span>
</pre>
		
		<pre class="file" id="file62" style="display: none">package mail

import (
        "fmt"
        "net/smtp"

        "github.com/jordan-wright/email"
)

const (
        smtpAuthAddress   = "smtp.gmail.com"
        smtpServerAddress = "smtp.gmail.com:587"
)

type EmailSender interface {
        SendEmail(subject, content string, to, cc, bcc []string) error
}

type GmailSender struct {
        name              string
        fromEmailAddress  string
        fromEmailPassword string
}

type GmailSenderOptions struct {
        Name              string
        FromEmailAddress  string
        FromEmailPassword string
}

func NewGmailSender(options *GmailSenderOptions) EmailSender <span class="cov8" title="1">{
        return &amp;GmailSender{
                name:              options.Name,
                fromEmailAddress:  options.FromEmailAddress,
                fromEmailPassword: options.FromEmailPassword,
        }
}</span>

func (sender *GmailSender) SendEmail(subject, content string, to, cc, bcc []string) error <span class="cov8" title="1">{
        e := email.NewEmail()
        e.From = fmt.Sprintf("%s &lt;%s&gt;", sender.name, sender.fromEmailAddress)
        e.Subject = subject
        e.HTML = []byte(content)
        e.To = to
        e.Cc = cc
        e.Bcc = bcc

        smtpAuth := smtp.PlainAuth("", sender.fromEmailAddress, sender.fromEmailPassword, smtpAuthAddress)
        return e.Send(smtpServerAddress, smtpAuth)
}</span>
</pre>
		
		<pre class="file" id="file63" style="display: none">package mail

func NewVerifyEmailTemplate(verifyUrl string) string <span class="cov8" title="1">{
        content := `
        &lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html dir="ltr" xmlns="http://www.w3.org/1999/xhtml" xmlns:o="urn:schemas-microsoft-com:office:office" lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;meta content="width=device-width, initial-scale=1" name="viewport"&gt;&lt;meta name="x-apple-disable-message-reformatting"&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;&lt;meta content="telephone=no" name="format-detection"&gt;&lt;title&gt;New Template&lt;/title&gt; &lt;!--[if (mso 16)]&gt;&lt;style type="text/css"&gt;     a {text-decoration: none;}     &lt;/style&gt;&lt;![endif]--&gt; &lt;!--[if gte mso 9]&gt;&lt;style&gt;sup { font-size: 100% !important; }&lt;/style&gt;&lt;![endif]--&gt; &lt;!--[if gte mso 9]&gt;&lt;xml&gt; &lt;o:OfficeDocumentSettings&gt; &lt;o:AllowPNG&gt;&lt;/o:AllowPNG&gt; &lt;o:PixelsPerInch&gt;96&lt;/o:PixelsPerInch&gt; &lt;/o:OfficeDocumentSettings&gt; &lt;/xml&gt;
        &lt;![endif]--&gt;&lt;style type="text/css"&gt;#outlook a { padding:0;}.es-button { mso-style-priority:100!important; text-decoration:none!important;}a[x-apple-data-detectors] { color:inherit!important; text-decoration:none!important; font-size:inherit!important; font-family:inherit!important; font-weight:inherit!important; line-height:inherit!important;}.es-desk-hidden { display:none; float:left; overflow:hidden; width:0; max-height:0; line-height:0; mso-hide:all;}@media only screen and (max-width:600px) {p, ul li, ol li, a { line-height:150%!important } h1, h2, h3, h1 a, h2 a, h3 a { line-height:120%!important } h1 { font-size:36px!important; text-align:left } h2 { font-size:26px!important; text-align:left } h3 { font-size:20px!important; text-align:left } .es-header-body h1 a, .es-content-body h1 a, .es-footer-body h1 a { font-size:36px!important; text-align:left }
         .es-header-body h2 a, .es-content-body h2 a, .es-footer-body h2 a { font-size:26px!important; text-align:left } .es-header-body h3 a, .es-content-body h3 a, .es-footer-body h3 a { font-size:20px!important; text-align:left } .es-menu td a { font-size:12px!important } .es-header-body p, .es-header-body ul li, .es-header-body ol li, .es-header-body a { font-size:14px!important } .es-content-body p, .es-content-body ul li, .es-content-body ol li, .es-content-body a { font-size:14px!important } .es-footer-body p, .es-footer-body ul li, .es-footer-body ol li, .es-footer-body a { font-size:14px!important } .es-infoblock p, .es-infoblock ul li, .es-infoblock ol li, .es-infoblock a { font-size:12px!important } *[class="gmail-fix"] { display:none!important } .es-m-txt-c, .es-m-txt-c h1, .es-m-txt-c h2, .es-m-txt-c h3 { text-align:center!important } .es-m-txt-r, .es-m-txt-r h1, .es-m-txt-r h2, .es-m-txt-r h3 { text-align:right!important }
         .es-m-txt-l, .es-m-txt-l h1, .es-m-txt-l h2, .es-m-txt-l h3 { text-align:left!important } .es-m-txt-r img, .es-m-txt-c img, .es-m-txt-l img { display:inline!important } .es-button-border { display:inline-block!important } a.es-button, button.es-button { font-size:20px!important; display:inline-block!important } .es-adaptive table, .es-left, .es-right { width:100%!important } .es-content table, .es-header table, .es-footer table, .es-content, .es-footer, .es-header { width:100%!important; max-width:600px!important } .es-adapt-td { display:block!important; width:100%!important } .adapt-img { width:100%!important; height:auto!important } .es-m-p0 { padding:0!important } .es-m-p0r { padding-right:0!important } .es-m-p0l { padding-left:0!important } .es-m-p0t { padding-top:0!important } .es-m-p0b { padding-bottom:0!important } .es-m-p20b { padding-bottom:20px!important } .es-mobile-hidden, .es-hidden { display:none!important }
         tr.es-desk-hidden, td.es-desk-hidden, table.es-desk-hidden { width:auto!important; overflow:visible!important; float:none!important; max-height:inherit!important; line-height:inherit!important } tr.es-desk-hidden { display:table-row!important } table.es-desk-hidden { display:table!important } td.es-desk-menu-hidden { display:table-cell!important } .es-menu td { width:1%!important } table.es-table-not-adapt, .esd-block-html table { width:auto!important } table.es-social { display:inline-block!important } table.es-social td { display:inline-block!important } .es-m-p5 { padding:5px!important } .es-m-p5t { padding-top:5px!important } .es-m-p5b { padding-bottom:5px!important } .es-m-p5r { padding-right:5px!important } .es-m-p5l { padding-left:5px!important } .es-m-p10 { padding:10px!important } .es-m-p10t { padding-top:10px!important } .es-m-p10b { padding-bottom:10px!important } .es-m-p10r { padding-right:10px!important }
         .es-m-p10l { padding-left:10px!important } .es-m-p15 { padding:15px!important } .es-m-p15t { padding-top:15px!important } .es-m-p15b { padding-bottom:15px!important } .es-m-p15r { padding-right:15px!important } .es-m-p15l { padding-left:15px!important } .es-m-p20 { padding:20px!important } .es-m-p20t { padding-top:20px!important } .es-m-p20r { padding-right:20px!important } .es-m-p20l { padding-left:20px!important } .es-m-p25 { padding:25px!important } .es-m-p25t { padding-top:25px!important } .es-m-p25b { padding-bottom:25px!important } .es-m-p25r { padding-right:25px!important } .es-m-p25l { padding-left:25px!important } .es-m-p30 { padding:30px!important } .es-m-p30t { padding-top:30px!important } .es-m-p30b { padding-bottom:30px!important } .es-m-p30r { padding-right:30px!important } .es-m-p30l { padding-left:30px!important } .es-m-p35 { padding:35px!important } .es-m-p35t { padding-top:35px!important }
         .es-m-p35b { padding-bottom:35px!important } .es-m-p35r { padding-right:35px!important } .es-m-p35l { padding-left:35px!important } .es-m-p40 { padding:40px!important } .es-m-p40t { padding-top:40px!important } .es-m-p40b { padding-bottom:40px!important } .es-m-p40r { padding-right:40px!important } .es-m-p40l { padding-left:40px!important } .es-desk-hidden { display:table-row!important; width:auto!important; overflow:visible!important; max-height:inherit!important } .h-auto { height:auto!important } }@media screen and (max-width:384px) {.mail-message-content { width:414px!important } }&lt;/style&gt;
         &lt;/head&gt; &lt;body style="width:100%;font-family:arial, 'helvetica neue', helvetica, sans-serif;-webkit-text-size-adjust:100%;-ms-text-size-adjust:100%;padding:0;Margin:0"&gt;&lt;div dir="ltr" class="es-wrapper-color" lang="en" style="background-color:#F9F7F7"&gt; &lt;!--[if gte mso 9]&gt;&lt;v:background xmlns:v="urn:schemas-microsoft-com:vml" fill="t"&gt; &lt;v:fill type="tile" color="#f9f7f7" origin="0.5, 0" position="0.5, 0"&gt;&lt;/v:fill&gt; &lt;/v:background&gt;&lt;![endif]--&gt;&lt;table class="es-wrapper" width="100%" cellspacing="0" cellpadding="0" role="none" style="mso-table-lspace:0pt;mso-table-rspace:0pt;border-collapse:collapse;border-spacing:0px;padding:0;Margin:0;width:100%;height:100%;background-repeat:repeat;background-position:center top;background-color:#F9F7F7"&gt;&lt;tr&gt;
        &lt;td valign="top" style="padding:0;Margin:0"&gt;&lt;table cellpadding="0" cellspacing="0" class="es-header" align="center" role="none" style="mso-table-lspace:0pt;mso-table-rspace:0pt;border-collapse:collapse;border-spacing:0px;table-layout:fixed !important;width:100%;background-color:transparent;background-repeat:repeat;background-position:center top"&gt;&lt;tr&gt;&lt;td align="center" style="padding:0;Margin:0"&gt;&lt;table bgcolor="#ffffff" class="es-header-body" align="center" cellpadding="0" cellspacing="0" role="none" style="mso-table-lspace:0pt;mso-table-rspace:0pt;border-collapse:collapse;border-spacing:0px;background-color:transparent;width:600px"&gt;&lt;tr&gt;
        &lt;td align="left" bgcolor="#ffffff" style="Margin:0;padding-top:10px;padding-bottom:10px;padding-left:20px;padding-right:20px;background-color:#ffffff"&gt;&lt;table cellpadding="0" cellspacing="0" width="100%" role="none" style="mso-table-lspace:0pt;mso-table-rspace:0pt;border-collapse:collapse;border-spacing:0px"&gt;&lt;tr&gt;&lt;td class="es-m-p0r" valign="top" align="center" style="padding:0;Margin:0;width:560px"&gt;&lt;table cellpadding="0" cellspacing="0" width="100%" role="presentation" style="mso-table-lspace:0pt;mso-table-rspace:0pt;border-collapse:collapse;border-spacing:0px"&gt;&lt;tr&gt;&lt;td align="left" style="padding:0;Margin:0;padding-top:10px;padding-bottom:10px;font-size:0px"&gt;&lt;img class="adapt-img" src="https://fejjswz.stripocdn.email/content/guids/CABINET_e2c5475cd85e4b8bc41c311189144f85195a784a1c00e3e43ef4432a56eb6a07/images/fundo.png" alt style="display:block;border:0;outline:none;text-decoration:none;-ms-interpolation-mode:bicubic" width="150"&gt;&lt;/td&gt;
         &lt;/tr&gt;&lt;/table&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; &lt;table cellpadding="0" cellspacing="0" class="es-content" align="center" role="none" style="mso-table-lspace:0pt;mso-table-rspace:0pt;border-collapse:collapse;border-spacing:0px;table-layout:fixed !important;width:100%"&gt;&lt;tr&gt;&lt;td align="center" style="padding:0;Margin:0"&gt;&lt;table bgcolor="#ffffff" class="es-content-body" align="center" cellpadding="0" cellspacing="0" role="none" style="mso-table-lspace:0pt;mso-table-rspace:0pt;border-collapse:collapse;border-spacing:0px;background-color:#FFFFFF;width:600px"&gt;&lt;tr&gt;&lt;td align="left" style="padding:0;Margin:0;padding-top:15px;padding-left:20px;padding-right:20px"&gt;&lt;table cellpadding="0" cellspacing="0" width="100%" role="none" style="mso-table-lspace:0pt;mso-table-rspace:0pt;border-collapse:collapse;border-spacing:0px"&gt;&lt;tr&gt;
        &lt;td align="center" valign="top" style="padding:0;Margin:0;width:560px"&gt;&lt;table cellpadding="0" cellspacing="0" width="100%" role="presentation" style="mso-table-lspace:0pt;mso-table-rspace:0pt;border-collapse:collapse;border-spacing:0px"&gt;&lt;tr&gt;&lt;td align="center" style="padding:15px;Margin:0;font-size:0px"&gt;&lt;img class="adapt-img" src="https://www.agentlocator.ca/Themes/Responsive/images/listings-banner.jpg" alt style="display:block;border:0;outline:none;text-decoration:none;-ms-interpolation-mode:bicubic" height="263"&gt;&lt;/td&gt; &lt;/tr&gt;&lt;tr&gt;&lt;td align="left" style="padding:0;Margin:0"&gt;&lt;p style="Margin:0;-webkit-text-size-adjust:none;-ms-text-size-adjust:none;mso-line-height-rule:exactly;font-family:'trebuchet ms', 'lucida grande', 'lucida sans unicode', 'lucida sans', tahoma, sans-serif;line-height:18px;color:#333333;font-size:12px"&gt;&lt;strong&gt;YOU'RE ONE STEP AWAY&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;
        &lt;td align="center" class="es-m-txt-c" style="padding:0;Margin:0;padding-top:5px;padding-bottom:5px"&gt;&lt;h1 style="Margin:0;line-height:38px;mso-line-height-rule:exactly;font-family:'trebuchet ms', 'lucida grande', 'lucida sans unicode', 'lucida sans', tahoma, sans-serif;font-size:32px;font-style:normal;font-weight:bold;color:#333333;text-align:left"&gt;Verify your email address&lt;/h1&gt;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td align="left" style="padding:0;Margin:0"&gt;&lt;p style="Margin:0;-webkit-text-size-adjust:none;-ms-text-size-adjust:none;mso-line-height-rule:exactly;font-family:'trebuchet ms', 'lucida grande', 'lucida sans unicode', 'lucida sans', tahoma, sans-serif;line-height:21px;color:#333333;font-size:14px"&gt;To complete your profile and start taking creativity projects with FundO, you'll need to verify your email address.&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;
        &lt;td align="left" style="padding:0;Margin:0;padding-top:20px;padding-left:20px;padding-right:20px"&gt;&lt;table cellpadding="0" cellspacing="0" width="100%" role="none" style="mso-table-lspace:0pt;mso-table-rspace:0pt;border-collapse:collapse;border-spacing:0px"&gt;&lt;tr&gt;&lt;td align="center" valign="top" style="padding:0;Margin:0;width:560px"&gt;&lt;table cellpadding="0" cellspacing="0" width="100%" role="presentation" style="mso-table-lspace:0pt;mso-table-rspace:0pt;border-collapse:collapse;border-spacing:0px"&gt;&lt;tr&gt;
        &lt;td align="center" style="padding:0;Margin:0;padding-top:20px;padding-bottom:20px"&gt;&lt;span class="es-button-border" style="border-style:solid;border-color:#2cb543;background:#5340ff;border-width:0px;display:inline-block;border-radius:28px;width:auto"&gt;&lt;a href="` + verifyUrl + `" class="es-button es-button-1710174798011" target="_blank" style="mso-style-priority:100 !important;text-decoration:none;-webkit-text-size-adjust:none;-ms-text-size-adjust:none;mso-line-height-rule:exactly;color:#FFFFFF;font-size:14px;padding:15px 60px;display:inline-block;background:#5340ff;border-radius:28px;font-family:verdana, geneva, sans-serif;font-weight:bold;font-style:normal;line-height:17px;width:auto;text-align:center;mso-padding-alt:0;mso-border-alt:10px solid #5340ff"&gt;Verify&lt;/a&gt; &lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;
        &lt;td align="left" style="padding:0;Margin:0;padding-bottom:10px;padding-left:20px;padding-right:20px"&gt;&lt;table cellpadding="0" cellspacing="0" width="100%" role="none" style="mso-table-lspace:0pt;mso-table-rspace:0pt;border-collapse:collapse;border-spacing:0px"&gt;&lt;tr&gt;&lt;td align="center" valign="top" style="padding:0;Margin:0;width:560px"&gt;&lt;table cellpadding="0" cellspacing="0" width="100%" style="mso-table-lspace:0pt;mso-table-rspace:0pt;border-collapse:separate;border-spacing:0px;border-radius:5px" role="presentation"&gt;&lt;tr&gt;&lt;td align="center" style="padding:0;Margin:0;padding-top:20px;padding-bottom:20px;font-size:0"&gt;&lt;table border="0" width="100%" height="100%" cellpadding="0" cellspacing="0" role="presentation" style="mso-table-lspace:0pt;mso-table-rspace:0pt;border-collapse:collapse;border-spacing:0px"&gt;&lt;tr&gt;&lt;td style="padding:0;Margin:0;border-bottom:1px solid #cccccc;background:unset;height:1px;width:100%;margin:0px"&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/td&gt;
        &lt;/tr&gt;&lt;tr&gt;&lt;td align="left" style="padding:0;Margin:0"&gt;&lt;p style="Margin:0;-webkit-text-size-adjust:none;-ms-text-size-adjust:none;mso-line-height-rule:exactly;font-family:'trebuchet ms', 'lucida grande', 'lucida sans unicode', 'lucida sans', tahoma, sans-serif;line-height:18px;color:#808080;font-size:12px"&gt;Contact&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align="left" style="padding:0;Margin:0;padding-top:10px;padding-bottom:10px"&gt;&lt;p style="Margin:0;-webkit-text-size-adjust:none;-ms-text-size-adjust:none;mso-line-height-rule:exactly;font-family:'trebuchet ms', 'lucida grande', 'lucida sans unicode', 'lucida sans', tahoma, sans-serif;line-height:18px;color:#a9a9a9;font-size:12px"&gt;Kasetsart University Bangkok, Thailand&lt;/p&gt;
         &lt;p style="Margin:0;-webkit-text-size-adjust:none;-ms-text-size-adjust:none;mso-line-height-rule:exactly;font-family:'trebuchet ms', 'lucida grande', 'lucida sans unicode', 'lucida sans', tahoma, sans-serif;line-height:18px;color:#a9a9a9;font-size:12px"&gt; 2024 FundO, Inc.&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;
`
        return content
}</span>
</pre>
		
		<pre class="file" id="file64" style="display: none">package pagination

import "math"

type PaginateOptions struct {
        Page int `form:"page" binding:"omitempty,min=1"`
        Size int `form:"size" binding:"omitempty,min=1"`
}

type PaginateFindOptions struct {
        Limit int
        Skip  int
}

type PaginateResult[T any] struct {
        Total       int64 `json:"total"`
        From        int   `json:"from"`
        To          int   `json:"to"`
        CurrentPage int   `json:"current_page"`
        LastPage    int   `json:"last_page"`
        PerPage     int   `json:"per_page"`
        Data        []T   `json:"data"`
} // @name PaginateResult

type MakePaginateContextParameters[T any] struct {
        PaginateOptions PaginateOptions
        CountDocuments  func() int64
        FindDocuments   func(findOptions PaginateFindOptions) []T
}

func MakePaginateResult[T any](parameters MakePaginateContextParameters[T]) PaginateResult[T] <span class="cov10" title="3">{
        paginateOptions := parameters.PaginateOptions
        countDocuments := parameters.CountDocuments
        findDocuments := parameters.FindDocuments

        size := paginateOptions.Size
        if size == 0 </span><span class="cov6" title="2">{
                size = 20
        }</span>

        <span class="cov10" title="3">currentPage := paginateOptions.Page
        if currentPage == 0 </span><span class="cov6" title="2">{
                currentPage = 1
        }</span>

        <span class="cov10" title="3">skip := (currentPage - 1) * size
        findOptions := PaginateFindOptions{
                Skip:  skip,
                Limit: size,
        }

        total := countDocuments()
        data := findDocuments(findOptions)

        lastPage := int(math.Ceil(float64(total) / float64(size)))
        to := skip + len(data)
        from := int(math.Min(float64(skip+1), float64(to)))

        return PaginateResult[T]{
                Total:       total,
                From:        from,
                To:          to,
                CurrentPage: currentPage,
                LastPage:    lastPage,
                PerPage:     size,
                Data:        data,
        }</span>
}
</pre>
		
		<pre class="file" id="file65" style="display: none">package password

import (
        "fmt"
        "unicode"

        "golang.org/x/crypto/bcrypt"
)

func HashPassword(password string) (string, error) <span class="cov4" title="4">{
        if !PasswordCondition(password) </span><span class="cov1" title="1">{
                return "", fmt.Errorf("password not match with the condition")
        }</span>
        <span class="cov3" title="3">hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to hash password: %w", err)
        }</span>

        <span class="cov3" title="3">return string(hashedPassword), nil</span>
}

func CheckPassword(password string, hashedPassword string) error <span class="cov2" title="2">{
        return bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(password))
}</span>

func PasswordCondition(password string) bool <span class="cov5" title="6">{
        var (
                upp, low, num, sym bool
                length             uint8
        )

        for _, char := range password </span><span class="cov10" title="56">{
                switch </span>{
                case unicode.IsUpper(char):<span class="cov4" title="4">
                        // uppercase character
                        upp = true
                        length++</span>
                case unicode.IsLower(char):<span class="cov9" title="44">
                        // lowercase character
                        low = true
                        length++</span>
                case unicode.IsNumber(char):<span class="cov4" title="4">
                        // numeric character
                        num = true
                        length++</span>
                case unicode.IsPunct(char) || unicode.IsSymbol(char):<span class="cov4" title="4">
                        // special character
                        sym = true
                        length++</span>
                default:<span class="cov0" title="0">
                        return false</span>
                }
        }

        <span class="cov5" title="6">if !upp || !low || !num || !sym || length &lt; 6 </span><span class="cov2" title="2">{
                return false
        }</span>

        <span class="cov4" title="4">return true</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">package random

import "fmt"

func NewEmail() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s@%s.com", NewString(10), NewString(5))
}</span>
</pre>
		
		<pre class="file" id="file67" style="display: none">package random

import "math/rand"

func NewInt(min, max int) int <span class="cov8" title="1">{
        return min + rand.Intn(max-min)
}</span>
</pre>
		
		<pre class="file" id="file68" style="display: none">package random

import "math/rand"

func NewString(length int) string <span class="cov4" title="3">{
        const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
        b := make([]byte, length)
        for i := range b </span><span class="cov10" title="25">{
                b[i] = charset[rand.Intn(len(charset))]
        }</span>
        <span class="cov4" title="3">return string(b)</span>
}
</pre>
		
		<pre class="file" id="file69" style="display: none">package token

import (
        "errors"
        "fmt"
        "time"

        jwt "github.com/dgrijalva/jwt-go"
)

const minSecretKeySize = 32

type JWTMaker struct {
        secretKey string
}

func NewJWTMaker(secretKey string) (Maker, error) <span class="cov10" title="3">{
        if len(secretKey) &lt; minSecretKeySize </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid key size: must be at least %d characters", minSecretKeySize)
        }</span>

        <span class="cov10" title="3">return &amp;JWTMaker{secretKey}, nil</span>
}

func (maker *JWTMaker) CreateToken(userID string, duration time.Duration) (string, *Payload, error) <span class="cov6" title="2">{
        payload, err := NewPayload(userID, duration)
        if err != nil </span><span class="cov0" title="0">{
                return "", payload, err
        }</span>

        <span class="cov6" title="2">jwtToken := jwt.NewWithClaims(jwt.SigningMethodHS256, payload)
        token, err := jwtToken.SignedString([]byte(maker.secretKey))
        return token, payload, err</span>
}

func (maker *JWTMaker) VerifyToken(token string) (*Payload, error) <span class="cov10" title="3">{
        keyFunc := func(token *jwt.Token) (interface{}, error) </span><span class="cov10" title="3">{
                _, ok := token.Method.(*jwt.SigningMethodHMAC)
                if !ok </span><span class="cov1" title="1">{
                        return nil, ErrInvalidToken
                }</span>
                <span class="cov6" title="2">return []byte(maker.secretKey), nil</span>
        }

        <span class="cov10" title="3">jwtToken, err := jwt.ParseWithClaims(token, &amp;Payload{}, keyFunc)
        if err != nil </span><span class="cov6" title="2">{
                verr, ok := err.(*jwt.ValidationError)
                if ok &amp;&amp; errors.Is(verr.Inner, ErrExpiredToken) </span><span class="cov1" title="1">{
                        return nil, ErrExpiredToken
                }</span>
                <span class="cov1" title="1">return nil, ErrInvalidToken</span>
        }

        <span class="cov1" title="1">payload, ok := jwtToken.Claims.(*Payload)
        if !ok </span><span class="cov0" title="0">{
                return nil, ErrInvalidToken
        }</span>

        <span class="cov1" title="1">return payload, nil</span>

}
</pre>
		
		<pre class="file" id="file70" style="display: none">package token

import (
        "errors"
        "time"

        "github.com/google/uuid"
)

var (
        ErrInvalidToken = errors.New("token is invalid")
        ErrExpiredToken = errors.New("token is expired")
)

type Payload struct {
        ID        uuid.UUID `json:"id"`
        UserID    string    `json:"user_id"`
        IssuedAt  time.Time `json:"issued_at"`
        ExpiredAt time.Time `json:"expired_at"`
}

func NewPayload(userId string, duration time.Duration) (*Payload, error) <span class="cov10" title="3">{
        tokenID, err := uuid.NewRandom()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov10" title="3">payload := &amp;Payload{
                ID:        tokenID,
                UserID:    userId,
                IssuedAt:  time.Now(),
                ExpiredAt: time.Now().Add(duration),
        }
        return payload, nil</span>
}

func (payload *Payload) Valid() error <span class="cov6" title="2">{
        if time.Now().After(payload.ExpiredAt) </span><span class="cov1" title="1">{
                return ErrExpiredToken
        }</span>
        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file71" style="display: none">package uploader

import (
        "context"
        "fmt"
        "github.com/aws/aws-sdk-go/aws"
        "github.com/aws/aws-sdk-go/aws/credentials"
        "github.com/aws/aws-sdk-go/aws/session"
        "github.com/aws/aws-sdk-go/service/s3/s3manager"
        "github.com/google/uuid"
        "github.com/rs/zerolog/log"
        "mime/multipart"
        "strings"
)

const (
        ProjectImageFolder = "projects"
        ProfileImageFolder = "profiles"
        PostImageFolder    = "posts"
)

type s3Store struct {
        uploader *s3manager.Uploader
        region   string
        bucket   string
}

type S3StoreConfig struct {
        Region             string
        Bucket             string
        AwsAccessKeyID     string
        AwsSecretAccessKey string
}

func NewS3Store(config *S3StoreConfig) (ImageUploader, error) <span class="cov0" title="0">{
        sess, err := session.NewSessionWithOptions(session.Options{
                Profile: "s3_user",
                Config: aws.Config{
                        Region:      aws.String(config.Region),
                        Credentials: credentials.NewStaticCredentials(config.AwsAccessKeyID, config.AwsSecretAccessKey, ""),
                        Logger:      aws.NewDefaultLogger(),
                },
        })

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;s3Store{
                uploader: s3manager.NewUploader(sess),
                region:   config.Region,
                bucket:   config.Bucket,
        }, nil</span>
}

func (s *s3Store) Upload(folder string, file *multipart.FileHeader) (string, error) <span class="cov0" title="0">{
        fileExtension := strings.Split(file.Filename, ".")[1]
        f, err := file.Open()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal().Err(err).Msg("Failed to open file")
                return "", err
        }</span>
        <span class="cov0" title="0">defer func(f multipart.File) </span><span class="cov0" title="0">{
                err := f.Close()
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal().Err(err).Msg("Failed to close file")
                }</span>
        }(f)

        <span class="cov0" title="0">id, err := uuid.NewUUID()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal().Err(err).Msg("Failed to generate UUID")
                return "", err
        }</span>

        <span class="cov0" title="0">result, err := s.uploader.UploadWithContext(context.TODO(), &amp;s3manager.UploadInput{
                Bucket: aws.String(s.bucket),
                Key:    aws.String(fmt.Sprintf("%s/%s.%s", folder, id.String(), fileExtension)),
                Body:   f,
                ACL:    aws.String("public-read"),
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal().Err(err).Msg("Failed to upload file")
                return "", err
        }</span>

        <span class="cov0" title="0">return result.Location, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
